TestCase subclass: #QuABasicTests	instanceVariableNames: 'capsule result obj obj2 reflection'	classVariableNames: ''	poolDictionaries: ''	category: 'QuATests-Prototype'!!QuABasicTests commentStamp: 'ras 3/11/2003 18:29' prior: 0!Step1: 	configure local file system with cache of qua/platform/squeak repository components:	- Squeak 3.4 image, VM executable, and sources files. 		(these are not QuA components - they do not encode QuA objects)		they are not Squeak components - they do not encode Squeak objects		the VM is an OS-application-component - it encodes an OS process object		the image and sources files are parts of a Squeak-VM-image-component	- QuA platform for squeak		this is not a QuA component - it does not encode a QuA object	- basic service planner	- implementation registry	- local persistent repository	publish in local repository components:	- HelloWorld type (in Smalltalk, type is represented by class, which is also the template for instance creation)	- HelloWorld template	test that we can configure a service with HelloWorld instance and run it correctly.test that a service can create a new service with a distinct service context, i.e., the new service context will use a different service planner.test that capsule can access multiple local persistent repositories:- cache of global repository immutable objects is locally persistent	at startup, repository discovers which persistent repositories are locally accessible and instantiates these (lazily?)	cache is local persistent store.	local persistent repositories are simple directories of binary files with name of logical repository and root directory identified in configuration file- discovery protocol for repositories executed at capsule initialization:	capsule init takes configuration properties that specify cache location and repository implementation	repository implementation is loaded from cache with capsule mechanisms, repository instantiation includes initialization	repository initialization looks in capsule configuration properties for local repository definition list	repository implementation determines when these local repositories are instantiated and verified as well as how resolution of names to repositories is implemented.	!!QuABasicTests methodsFor: 'Testing' stamp: 'ras 3/5/2003 22:20'!obj2: anObject	obj2 _ anObject! !!QuABasicTests methodsFor: 'Testing' stamp: 'ras 4/15/2005 15:25'!obj: anObject	obj _ anObject! !!QuABasicTests methodsFor: 'Testing' stamp: 'ras 5/31/2005 13:56'!setUp	QuA platformInitialize.	capsule _ QuA thisCapsule.	capsule	serveRepository: (FileBasedRepository named: '/demo').	QuA publish: (capsule serializationFromClass: Gen) name: '/demo/GenFactory-blueprint'.  	QuA publish: (capsule serializationFromClass: Sum) name: '/demo/SumFactory-blueprint'.  ! !!QuABasicTests methodsFor: 'Testing' stamp: 'ras 5/7/2004 15:33'!tearDown	capsule shutdown! !!QuABasicTests methodsFor: 'Testing' stamp: 'ras 5/31/2005 13:50'!testPublish	| blueprintName |	blueprintName _ '/demo/HelloWorldFactory-blueprint'.		QuA publish: (capsule serializationFromClass: HelloWorld) name: blueprintName.	capsule		advertise: '/demo/HelloWorld' qua		and: '/demo/HelloWorldFactory' qua		sourceCode: blueprintName qua		requires: SvcMap none.	obj _ (QuA instantiate: '/demo/HelloWorld' qua) primaryInterface.	obj output: self.	obj run.	self assert: result = 'Hello World'! !!QuABasicTests methodsFor: 'Testing' stamp: 'ras 5/31/2005 13:52'!testThreeComponentService	| testComposition |	capsule		advertise: '/demo/Gen' qua		and: '/demo/GenFactory' qua		sourceCode: '/demo/GenFactory-blueprint' qua		requires: SvcMap none.	capsule		advertise: '/demo/Sum' qua		and: '/demo/SumFactory' qua		sourceCode: '/demo/SumFactory-blueprint' qua		requires: SvcMap none.	testComposition _ QuAComposition new		addInstanceOf: '/demo/Gen' qua role: 'gen';		addInstanceOf: '/demo/Sum' qua role: 'sum';		addObject: self role: 'self';		set: 'gen' property: 'output' to: 'sum';		set: 'self' property: 'obj' to: 'gen';		set: 'self' property: 'obj2' to: 'sum';		yourself.	QuA advertise: (ServiceMirror type: '/demo/test' qua architecture: testComposition).	QuA instantiate: '/demo/test' qua.		obj gen1To: 3.			self assert: ( obj2 sum = 6 ).	! !!QuABasicTests methodsFor: 'Testing' stamp: 'ras 2/29/2020 18:45'!testVersion	self assert: Smalltalk version = 'Squeak5.2'.	"self assert: Smalltalk lastUpdateString = 'latest update: #18229'."	"self assert: Smalltalk changes name = 'QuA proto'."	"self assert: Smalltalk changes isEmpty."	"empty only with fresh image"! !!QuABasicTests methodsFor: 'Testing' stamp: 'ras 3/4/2003 18:16'!value: anObject	result _ anObject! !TestCase subclass: #QuAChessTest	instanceVariableNames: 'capsule result game'	classVariableNames: 'BrokerIsSetUp RepositoryIsSetUp'	poolDictionaries: ''	category: 'QuATests-Prototype'!!QuAChessTest methodsFor: 'Testing' stamp: 'ras 5/31/2005 13:46'!fullSetUp	RepositoryIsSetUp _ BrokerIsSetUp _ false.  "force setup of repository and broker"	self setUp.! !!QuAChessTest methodsFor: 'Testing' stamp: 'ras 6/1/2005 10:01'!persistentBrokerSetUp	"BrokerIsSetUp ifTrue: [^self]."	capsule		advertise: '/demo/Chess' qua		and: '/demo/ChessFactory' qua		sourceCode: '/demo/ChessFactory-blueprint' qua		requires: (SvcMap fromTypes: { 			'board'-> '/demo/Board' qua. 			'player1'-> '/demo/Robot' qua. 			'player2'-> '/demo/Robot' qua.  }).	capsule		advertise: '/demo/Robot' qua		and: '/demo/RobotFactory' qua		sourceCode: '/demo/RobotFactory-blueprint' qua		requires: SvcMap none.	capsule		advertise: '/demo/Board' qua		and: '/demo/BoardFactory' qua		sourceCode: '/demo/BoardFactory-blueprint' qua		requires: SvcMap none."	BrokerIsSetUp _ true."! !!QuAChessTest methodsFor: 'Testing' stamp: 'ras 5/31/2005 13:45'!persistentRepositorySetUp	RepositoryIsSetUp ifTrue: [^self].	QuA publish: (capsule serializationFromClass: Chess) name: '/demo/ChessFactory-blueprint'.  	QuA publish: (capsule serializationFromClass: Board) name: '/demo/BoardFactory-blueprint'.  	QuA publish: (capsule serializationFromClass: Robot) name: '/demo/RobotFactory-blueprint'.	RepositoryIsSetUp _ true.! !!QuAChessTest methodsFor: 'Testing' stamp: 'ras 5/31/2005 13:38'!setUp	QuA platformInitialize.	capsule _ QuA thisCapsule.	capsule	serveRepository: (FileBasedRepository named: '/demo').	self persistentRepositorySetUp.	self persistentBrokerSetUp.! !!QuAChessTest methodsFor: 'Testing' stamp: 'ras 3/17/2004 10:26'!tearDown	capsule shutdown! !!QuAChessTest methodsFor: 'Testing' stamp: 'ras 5/21/2005 00:38'!testPlay	game _ QuA instanceOf: '/demo/Chess' qua.	result _ game play.	self assert: ((result = 'white') or: [ (result = 'black') or: [ result = 'draw'. ]. ]).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuAChessTest class	instanceVariableNames: ''!!QuAChessTest class methodsFor: 'as yet unclassified' stamp: 'ras 5/31/2005 13:47'!initialize	"QuAChessTest initialize"	BrokerIsSetUp _ false.	RepositoryIsSetUp _ false.! !TestCase subclass: #QuAImplBrokerTest	instanceVariableNames: 'capsule result obj obj2 reflection'	classVariableNames: 'BrokerIsSetUp RepositoryIsSetUp'	poolDictionaries: ''	category: 'QuATests-Prototype'!!QuAImplBrokerTest commentStamp: 'ras 1/28/2004 10:21' prior: 0!In setup, we advertise two blueprints; one for a factory and one for an instance:	plan: blueprint for XFactory, blueprint name XFactoryBlueprint, requires SqueakCapsule		means get an instance of SqueakCapsule and tell it to instantiate an XFactory from blueprint XFactoryBlueprint	plan: blueprint for X, blueprint name XBlueprint, requires SqueakCapsule		means get an instance of SqueakCapsule and tell it to instantiate an X from blueprint XBlueprintNow the type XFactory can also be advertised as a way to create instances of X:	plan: manufacture X, requires XFactory		means tell XFactoryInstance to manufacture an XAn instance may be advertised as a plan to satisfy a type:	plan: instance of X, name XInstance		means can use XInstance as instance of X	plan: instance of XFactory, name XFactoryInstance		means can use XFactoryInstance as instance of XFactorySo, if we begin service planning with the above plans in our implementationBroker and the following goal:	goal: instance of Xwe should get the following plan alternatives:1	plan: instance of X, name XInstance2	plan: manufacture X, requires XFactory	3	plan: blueprint for X, blueprint name XBlueprint, requires SqueakCapsulePlan 1 is easiest to execute, just use XInstance.Plan 2 requires an instance of XFactory, so service planning must be invoked again with the goal:	goal: instance of XFactorywhich should get the following results:4	plan: instance of XFactory, name XFactoryInstance5	plan: blueprint for XFactory, blueprint name XFactoryBlueprint, requires SqueakCapsuleAgain, plan 4 is trivial, but plan 5 requires an instance of SqueakCapsule:	goal: instance of SqueakCapsuleThis goal could be satisfied by the local capsule, but if not, the ImplementationBroker would have to return plans to use remote instances that had been advertised or possibly some plan to manufacture instances.Plan 5 then represents as many plans as there are bindings for the SqueakCapsule requirement.Similarly, plan 3 represents as many plans as there are bindings for the SqueakCapsule requirement.If plans 1, 3 and 4 did not exist (or were not selected for any other reason), the result of service planning would be a plan that selected a SqueakCapsule, told it to instantiate an XFactory from XBlueprint, then told this XFactory to manufacture an X.A side effect of instantiating the XFactory might be that the capsule chooses to advertise this as seen in plan 4.A repeat request for an instance of X might then be satisfied by executing plan 4 to get the factory and then executing plan 2 for the instance.!!QuAImplBrokerTest methodsFor: 'Testing' stamp: 'ras 5/31/2005 14:04'!persistentBrokerSetUp	QuA thisCapsule 		advertise: '/demo/TestComponent' qua		and: '/demo/TestComponentFactory' qua		sourceCode: '/demo/TestComponentFactory-blueprint' qua		requires: SvcMap none.! !!QuAImplBrokerTest methodsFor: 'Testing' stamp: 'ras 5/31/2005 14:02'!persistentRepositorySetUp	RepositoryIsSetUp ifTrue: [^self].	QuA publish: (capsule serializationFromClass: TestComponentFactory) name: '/demo/TestComponentFactory-blueprint'.  	RepositoryIsSetUp _ true.! !!QuAImplBrokerTest methodsFor: 'Testing' stamp: 'ras 5/31/2005 14:00'!setUp	QuA platformInitialize.	capsule _ QuA thisCapsule.	capsule serveRepository: (FileBasedRepository named: '/demo').	self persistentRepositorySetUp.	self persistentBrokerSetUp.! !!QuAImplBrokerTest methodsFor: 'Testing' stamp: 'ras 5/7/2004 15:32'!tearDown	capsule shutdown! !!QuAImplBrokerTest methodsFor: 'Testing' stamp: 'ras 12/15/2004 12:27'!testGetFactory		obj _ QuA instanceOf: '/demo/TestComponentFactory' qua.		self assert: (obj new hello = 'Hello World').! !!QuAImplBrokerTest methodsFor: 'Testing' stamp: 'ras 5/16/2005 12:02'!testGetInstanceByFactory	| broker |		broker _ QuA thisServiceContext implementationBroker.		"make sure there are no instances, so that one must be manufactured by factory"		broker removeAll: ((broker plansFor: (QuA reflectOn: '/demo/TestComponent' qua)) select: [ :plan | plan isAssembled. ]).		obj _ QuA instanceOf: '/demo/TestComponent'qua.		self assert: (obj hello = 'Hello World').! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuAImplBrokerTest class	instanceVariableNames: ''!!QuAImplBrokerTest class methodsFor: 'as yet unclassified' stamp: 'ras 5/31/2005 14:03'!initialize	"QuAImplBrokerTest initialize"	BrokerIsSetUp _ false.	RepositoryIsSetUp _ false.! !TestCase subclass: #QuANameTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'QuATests-Prototype'!!QuANameTests methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 11:54'!testParse	| name |	name _ QuAName fromString: '/a/b/c:1.0'.	self assert: ( name repositoryNameString = '/a/b' ).	self assert: ( name shortName = 'c' ).	self assert: ( name version = 1 ).	self assert: ( name fixLevel = 0 ).! !!QuANameTests methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 11:55'!testParseCanonical	| name |	name _ QuAName fromString: '/a/b/c:1.0'.	name _ QuAName fromString: name printString.	self assert: ( name repositoryNameString = '/a/b' ).	self assert: ( name shortName = 'c' ).	self assert: ( name version = 1 ).	self assert: ( name fixLevel = 0 ).! !TestCase subclass: #QuAObjectTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'QuATests-Prototype'!!QuAObjectTests methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 13:28'!testBaseProtocol	| obj  |	obj _ QuAObject named: (QuA thisCapsule defaultRepository quaName).	self assert: (obj notNil).	self assert: ( (obj quaName) = (QuA thisCapsule defaultRepository quaName) ).! !!QuAObjectTests methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 10:51'!testClass	| obj nameString |	nameString _ '/a/b/c:1.0'.	obj _ nameString qua.	self assert: ( obj class = QuAObject ).! !!QuAObjectTests methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 12:05'!testQuAName	| obj nameString |	nameString _ '/a/b/c:1.0'.	obj _ nameString qua.	self assert: ( (QuA nameFor: obj) = (QuAName fromString: nameString) ).! !TestCase subclass: #QuAQRMIMarshaling	instanceVariableNames: 'source sink capsule'	classVariableNames: 'BrokerIsSetUp RepositoryIsSetUp'	poolDictionaries: ''	category: 'QuATests-Prototype'!!QuAQRMIMarshaling methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 22:10'!receiver: receiverName selector: selector args: args result: result	| socket myProtocol |	socket _ ReadWriteStream on: String new.	myProtocol _ QRMIProtocol new.	myProtocol write: receiverName selector: selector arguments: args to: socket.	socket reset.	self assert: (myProtocol readReceiverFrom: socket) = receiverName.	self assert: (myProtocol readSelectorFrom: socket) = selector.	self assert: (myProtocol readArgumentsFrom: socket) = args.	socket resetContents.	myProtocol marshalObj: result on: socket.	socket nextPutAll: String crlf.	socket reset.	self assert: (myProtocol unmarshalObjFrom: socket upToEnd) = result.! !!QuAQRMIMarshaling methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 22:21'!setUp	QuA platformInitialize.! !!QuAQRMIMarshaling methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 22:22'!tearDown	QuA thisCapsule shutdown.! !!QuAQRMIMarshaling methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 22:27'!testMoreComplex	self receiver: (QuAName fromString: '/qua/repository/T1') selector: #= args: { -17. 'abc'. '/rep' qua. } result: Dictionary new.! !!QuAQRMIMarshaling methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 22:43'!testNilArgs	self receiver: (QuAName fromString: '/qua/repository/T1') selector: #unary args: { nil. true. #(nil nil). } result: self.! !!QuAQRMIMarshaling methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 22:22'!testSimpleOperation	self receiver: (QuAName fromString: '/c1') selector: #do: args: { 1. } result: $z.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuAQRMIMarshaling class	instanceVariableNames: ''!!QuAQRMIMarshaling class methodsFor: 'as yet unclassified' stamp: 'ras 6/7/2005 11:44'!initialize	"QuAQRMIMarshaling initialize"	BrokerIsSetUp _ false.	RepositoryIsSetUp _ false.! !TestCase subclass: #QuAQRMITest	instanceVariableNames: 'source sink capsule c1Name c2Name c1HostName c2HostName c1PortNum c2PortNum cacheFileName'	classVariableNames: 'BrokerIsSetUp RepositoryIsSetUp'	poolDictionaries: ''	category: 'QuATests-Prototype'!!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/2/2005 08:03'!cacheFileName	^cacheFileName! !!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/2/2005 08:03'!initialize	c1Name _ '/c1'.	c2Name _ '/c2'.	c1HostName _ 'localhost'.	c2HostName _ 'localhost'.	c1PortNum _ 8301.	c2PortNum _ 8302.	cacheFileName _ 'initGlobalCache'! !!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/2/2005 08:19'!persistentBrokerSetUp	"BrokerIsSetUp ifTrue: [^self]."	{ 'QRMIProxy'. 'QRMIProtocol'. 'QRMIAdapter'. 'TestDataType'. }		do: [ :className |			capsule				advertise: ('/demo/',className) qua				and: ('/demo/',className,'Factory') qua				sourceCode: ('/demo/' , className, 'Factory-blueprint') qua				requires: SvcMap none.	]."	BrokerIsSetUp _ true."! !!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 22:15'!persistentRepositorySetUp	RepositoryIsSetUp ifTrue: [^self].	{ QRMIProxy. QRMIProtocol. QRMIAdapter. TestDataType. }		do: [ :class |			QuA publish: (capsule serializationFromClass: class) name: '/demo/',class name asString,'Factory-blueprint'.  		].	RepositoryIsSetUp _ true.! !!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/6/2005 11:09'!setUp	"This test assumes a remote smalltalk image is already running, 	serving capsule2 (repository /c2).  To set up this external state, 	select the next two lines and DoIt:		QuAQRMITest initialize.		QuAQRMITest new sharedPersistentSetUp.	Then in another QuA image on this same host, same directory 	(for access to initialization blueprint cache file), 	select the following line and DoIt:		QuAQRMITest new startCapsule2.	Finally, return to this image and run the test."	| remoteAdapter |	QuA initializeWithName: c1Name.	capsule _ QuA thisCapsule.	capsule	serveRepository: (FileBasedRepository named: '/demo').	self persistentBrokerSetUp.	capsule cacheStateFromFile: (cacheFileName).	remoteAdapter _ QuA instanceOf: '/demo/QRMIAdapter' qua.	remoteAdapter enableListenerOnPort: c1PortNum.	capsule 		advertiseCapabilityPlan: c2Name qua		factory: '/demo/QRMIProxyFactory' qua		configuration: (SvcMap fromValues: { 'host'->c2HostName. 'port'->c2PortNum. }).! !!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/2/2005 08:01'!sharedPersistentSetUp	"copy blueprints needed for bootstrapping to cache file"	| demoRepository cache blueprintQuAName |	QuA platformInitialize.	capsule _ QuA thisCapsule.	demoRepository _ capsule serveRepository: (FileBasedRepository named: '/demo').	self persistentRepositorySetUp.	cache _ Dictionary new.	{ 'QRMIProxy'. 'QRMIProtocol'. 'QRMIAdapter' }		do: [ :className |			blueprintQuAName _ QuAName fromString: ('/demo/',className,'Factory-blueprint').			cache at: blueprintQuAName put: (demoRepository quaObjAt: blueprintQuAName).		].	(FileStream forceNewFileNamed: self cacheFileName) fileOutClass: nil andObject: cache.! !!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/5/2005 19:46'!startCapsule2	"QuAQRMITest new startCapsule2"	| remoteAdapter |	QuA initializeWithName: c2Name.	capsule _ QuA thisCapsule.	self persistentBrokerSetUp.	capsule cacheStateFromFile: (cacheFileName).	remoteAdapter _ QuA instanceOf: '/demo/QRMIAdapter' qua.	remoteAdapter enableListenerOnPort: c2PortNum.	capsule 		advertiseCapabilityPlan: c1Name qua		factory: '/demo/QRMIProxyFactory' qua		configuration: (SvcMap fromValues: { 'host'->c1HostName. 'port'->c1PortNum. }).	self persistentBrokerSetUp.self halt.	QuA thisCapsule shutdown.! !!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 11:35'!tearDown	capsule shutdown! !!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/6/2005 13:30'!testRemoteAccess	self assert: ((c2Name qua) quaName = (QuAName fromString: (c2Name))).! !!QuAQRMITest methodsFor: 'as yet unclassified' stamp: 'ras 6/6/2005 14:31'!testRemoteInstantiation	| remoteService remoteFactoryService testObj |	remoteService _ ServiceMirror type: '/demo/TestDataType' qua.	remoteFactoryService _ QuA thisServiceContext planner plan: (ServiceMirror type: '/demo/TestDataTypeFactory' qua) in: QuA thisServiceContext.	remoteFactoryService architecture platform: (ServiceMirror implementation: '/c2' qua).	remoteService architecture: (Architecture		platform: remoteFactoryService		blueprint: nil		components: SvcMap none		qosRelations: QoSRelations unknown).	remoteService state: ServiceArchitected state.	testObj _ remoteService run; primaryInterface.	testObj v1: 'first '.	testObj v2: 'second'.	self assert: (testObj cat = ('first ' printString, 'second' printString)).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuAQRMITest class	instanceVariableNames: ''!!QuAQRMITest class methodsFor: 'as yet unclassified' stamp: 'ras 6/2/2005 07:59'!initialize	"QuAQRMITest initialize"	BrokerIsSetUp _ false.	RepositoryIsSetUp _ false.! !TestCase subclass: #QuAVideoBinding	instanceVariableNames: 'qSpec mpegPlan h263Plan capsule errorModel'	classVariableNames: 'BrokerIsSetUp RepositoryIsSetUp'	poolDictionaries: ''	category: 'QuATests-Prototype'!!QuAVideoBinding commentStamp: 'ras 4/18/2005 16:14' prior: 0!Validate example from RM2004 paper:  Select video binding based on utility of error prediction for MPEG, versus H263 video over a wireless link.  However, this test simulates the wireless network and video components so that all that is actually tested is the mechanics of representing error predictions and calculating utility for plans.video binding QoS depends on:  src resolution and framerate  transcoder resolution and frame loss  netpipe capacity and jitter  buffer ability to handle netpipe jitter  sink resolution and framerate capacitySrc and sink are predetermined by application choice of content and display location, but these components may be queried during service planning to identify input guarantee (src resoluton and framerate) and output capacity (resolution and framerate).Enumeration of alternative plans should consider only "VideoPlayer" implementations: an abstract type for a component framework that knows how to compose a VSrc and VSink, with appropriate communication and transcoding to adapt the source to the output device.  !!QuAVideoBinding methodsFor: 'as yet unclassified' stamp: 'ras 5/31/2005 14:35'!persistentBrokerSetUp	| h263Predictor mpegPredictor |	h263Predictor := TH263Estimator new errorModel: errorModel.	mpegPredictor := TMPEGEstimator new errorModel: errorModel.	{ 'VSrc'. 'MPEG2H263'. 'NetPipe'. 'VBuffer'. 'MPEGDecoder'. 'H263Decoder'. 'VDisp'} 		do: [:each | 				QuA thisCapsule 					advertise: ('/demo/',each) qua					and: ('/demo/',each,'Factory') qua					sourceCode: ('/demo/',each,'Factory-blueprint') qua					requires: SvcMap none					errorEstimator: nil.		].	mpegPlan := QuAComposition new.	{'VSrc'. 'NetPipe'. 'VBuffer'. 'MPEGDecoder'. 'VDisp'}		do: [:each | mpegPlan addInstanceOf: ('/demo/' , each) qua role: each].	mpegPlan		set: 'VSrc' property: 'sink' to: 'NetPipe';		set: 'NetPipe' property: 'sink' to: 'VBuffer';		set: 'MPEGDecoder' property: 'source' to: 'VBuffer';		set: 'MPEGDecoder' property: 'sink' to: 'VDisp';		qosRelations: (QoSRelations errorPredictor: mpegPredictor).	QuA advertise: (ServiceMirror type: '/demo/videoPlayer' qua 	architecture: mpegPlan).	h263Plan := QuAComposition new.	{ 'VSrc'. 'MPEG2H263'. 'NetPipe'. 'VBuffer'. 'H263Decoder'. 'VDisp'}		do: [:each | h263Plan addInstanceOf: ('/demo/' , each) qua role: each].	h263Plan		set: 'VSrc' property: 'sink' to: 'MPEG2H263';		set: 'MPEG2H263' property: 'sink' to: 'NetPipe';		set: 'NetPipe' property: 'sink' to: 'VBuffer';		set: 'H263Decoder' property: 'source' to: 'VBuffer';		set: 'H263Decoder' property: 'sink' to: 'VDisp';		qosRelations: (QoSRelations errorPredictor: h263Predictor).	QuA advertise: (ServiceMirror type: '/demo/videoPlayer' qua 	architecture: h263Plan).! !!QuAVideoBinding methodsFor: 'as yet unclassified' stamp: 'ras 5/31/2005 14:22'!persistentRepositorySetUp	RepositoryIsSetUp ifTrue: [^self].	{ 'VSrc'. 'MPEG2H263'. 'NetPipe'. 'VBuffer'. 'MPEGDecoder'. 'H263Decoder'. 'VDisp'} 		do: [:each | QuA			publish: (capsule serializationFromClass: (Smalltalk at: ('T',each) asSymbol))			name: '/demo/',each,'Factory-blueprint'.		].	QuA 		publish: (ErrorModel dimensions: { 'delay'. 'period'. 'noise'})		name: '/demo/VideoPlayerErrorModel'.	RepositoryIsSetUp _ true.! !!QuAVideoBinding methodsFor: 'as yet unclassified' stamp: 'ras 5/31/2005 14:35'!setUp	QuA initializeWithName: '/c1'.	capsule _ QuA thisCapsule.	capsule	serveRepository: (FileBasedRepository named: '/demo').	self persistentRepositorySetUp.	errorModel := '/demo/VideoPlayerErrorModel' qua.	self persistentBrokerSetUp.	qSpec := (QuA qualitySpec)				errorModel: errorModel;				inputGuarantee: ((QuA inputSpec)							interface: '/demo/videoPlayer' qua;							properties: ((Dictionary new)										at: 'period' put: 33;										at: 'size' put: 40000;										at: 'resolution' put: 300000;										yourself);							yourself);				utility: ((UtilityFunction new)							weights: ((Dictionary new)										at: 'delay' put: 1000;										at: 'period' put: 200;										at: 'noise' put: 0.2;										yourself);							errorModel: errorModel;							yourself);				yourself	"Duration milliSeconds: "	"Duration milliSeconds:"	"Duration milliSeconds:"! !!QuAVideoBinding methodsFor: 'as yet unclassified' stamp: 'ras 8/25/2004 17:29'!tearDown	QuA thisCapsule shutdown! !!QuAVideoBinding methodsFor: 'as yet unclassified' stamp: 'ras 6/4/2005 00:26'!testVBinding	| player testVSrc testVDisp |	testVSrc _ QuA instanceOf: '/demo/VSrc' qua.	testVDisp _ QuA instanceOf: '/demo/VDisp' qua.	player _ QuA 		instantiate: '/demo/videoPlayer' qua		properties: (SvcMap fromValues: { 'VSrc'->testVSrc. 'VDisp'->testVDisp. })		quality: qSpec.	player run.		self assert: (player architecture match: mpegPlan) notNil.! !!QuAVideoBinding methodsFor: 'as yet unclassified' stamp: 'ras 6/4/2005 00:25'!testVBindingWithQuality	| player testVSrc testVDisp |	QuA thisServiceContext 		planner: QoSServicePlanner new.	testVSrc _ QuA instanceOf: '/demo/VSrc' qua.	testVDisp _ QuA instanceOf: '/demo/VDisp' qua.	player _ QuA 		instantiate: '/demo/videoPlayer' qua		properties: (SvcMap fromValues: { 'VSrc'->testVSrc. 'VDisp'->testVDisp. })		quality: qSpec.	player run.		self assert: (player architecture match: h263Plan) notNil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuAVideoBinding class	instanceVariableNames: ''!!QuAVideoBinding class methodsFor: 'as yet unclassified' stamp: 'ras 5/31/2005 14:20'!initialize	"QuAVideoBinding initialize"	BrokerIsSetUp _ false.	RepositoryIsSetUp _ false.! !QuAChessTest initialize!QuAImplBrokerTest initialize!QuAQRMIMarshaling initialize!QuAQRMITest initialize!QuAVideoBinding initialize!