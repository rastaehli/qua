Object subclass: #Architecture	instanceVariableNames: 'platformService blueprint componentServices qosRelations'	classVariableNames: 'ArchitectureUnknown'	poolDictionaries: ''	category: 'QuA'!!Architecture commentStamp: 'ras 5/11/2005 15:20' prior: 0!Instances of this class describe how a service is assembled from components.  Instances may be sent the message #instantiate to construct a service instance with this architecture.  Instances may also be used to reflect on how a running service was constructed.Structure: platform -- 	a ServiceMirror identifying the type of platform to				construct the service.  Of course, a ServiceMirror				might specify the platform implementation as well. blueprint --	an Object instructing the platform how to assemble 				components into a service implementation.  This should				be an immutable value, such as source code. componentServices --	a Dictionary mapping component names to				ServiceMirror instances, these are arguments to the 				service constructor #instantiate:with.				!!Architecture methodsFor: 'accessing' stamp: 'ras 5/12/2005 23:12'!= anArchitecture	"return true only if anArchitecture is structurally equivalent"	platformService = anArchitecture platform ifFalse: [ ^false. ].	blueprint = anArchitecture blueprint ifFalse: [ ^false. ].	componentServices = anArchitecture componentServices ifFalse: [ ^false. ].	qosRelations = anArchitecture qosRelations ifFalse: [ ^false. ].	^true.! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:02'!blueprint	^blueprint! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:02'!blueprint: anObject	blueprint := anObject! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/5/2005 13:45'!componentServices	^componentServices! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/5/2005 13:45'!componentServices: anObject	componentServices := anObject! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/16/2005 14:58'!errorFor: anErrorModel	anErrorModel = qosRelations errorPredictor errorModel ifFalse: [ self error: 'error model does not match'. ].	^qosRelations errorPredictor errorForPlatform: platformService andComponents: componentServices! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/9/2005 17:44'!instantiate	^self platform primaryInterface			instantiate: blueprint 			with: componentServices! !!Architecture methodsFor: 'accessing' stamp: 'ras 6/3/2005 21:53'!instantiateWith: properties	"provide both behavior properties and components services to construct service"	^self platform primaryInterface			instantiate: blueprint 			with: (properties copy 				addAll: componentServices;				yourself).! !!Architecture methodsFor: 'accessing' stamp: 'ras 6/3/2005 18:13'!match: spec	"If this Architecture could conform to spec, return a copy specialized to match."	| copy |	blueprint = spec blueprint ifFalse: [ ^nil. ].	copy _ spec shallowCopy.	copy platform: (self platform match: spec platform).	copy platform ifNil: [^nil].	copy componentServices: spec componentServices copy.	self componentServices keysAndValuesDo: [ :key :value |		copy componentServices at: key 			put: (value match: (spec componentServices 				at: key ifAbsent: [^nil])).		(copy componentServices at: key) ifNil: [^nil].	].	copy qosRelations: (self qosRelations match: spec qosRelations).	copy qosRelations ifNil: [^nil].	^copy.! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/27/2005 23:52'!objectForDataStream: refStrm    "Return an object to store on an external data stream."    (QuA isQuAProxy: blueprint)		ifTrue: [ ^self. ]		ifFalse: [ ^self copy blueprint: (QuAObject for: blueprint). ].! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/6/2005 14:18'!platform	^platformService! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/6/2005 14:18'!platform: anObject	platformService := anObject! !!Architecture methodsFor: 'accessing' stamp: 'ras 6/3/2005 13:48'!postCopy	"finish shallow copy with copy of component object Dictionary"	self componentServices: self componentServices copy.! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:02'!qosRelations	^qosRelations! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:02'!qosRelations: anObject	qosRelations := anObject! !!Architecture methodsFor: 'accessing' stamp: 'ras 5/13/2005 12:11'!unresolvedDependencies	| result |	result _ Dictionary new.	platformService isProvisioned ifFalse: [ result at: 'platform' put: platformService. ].	componentServices keysAndValuesDo: [ :name :svc |		svc isProvisioned ifFalse: [ result at: name put: svc. ].	].	^result.! !!Architecture methodsFor: 'as yet unclassified' stamp: 'ras 5/16/2005 15:01'!initialize	componentServices _ Dictionary new.	qosRelations _ QoSRelations unknown.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Architecture class	instanceVariableNames: ''!!Architecture class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 12:50'!initialize	ArchitectureUnknown _ nil.! !!Architecture class methodsFor: 'as yet unclassified' stamp: 'ras 5/11/2005 15:44'!platform: platformSvcMirror blueprint: blueprintSvcMirror components: aMap qosRelations: aQoSRelation	^self new		platform: platformSvcMirror;		blueprint: blueprintSvcMirror;		componentServices: aMap;		qosRelations: aQoSRelation;		yourself! !!Architecture class methodsFor: 'as yet unclassified' stamp: 'ras 5/11/2005 18:46'!unknown	ArchitectureUnknown ifNil: [		ArchitectureUnknown _ self new.	].	^ArchitectureUnknown! !Architecture subclass: #ArchitecturePrimitive	instanceVariableNames: ''	classVariableNames: 'Singleton'	poolDictionaries: ''	category: 'QuA'!!ArchitecturePrimitive methodsFor: 'as yet unclassified' stamp: 'ras 5/11/2005 13:37'!instantiate	self shouldNotImplement! !!ArchitecturePrimitive methodsFor: 'as yet unclassified' stamp: 'ras 6/4/2005 00:15'!match: spec	(spec == self) 		ifTrue: [^self]		ifFalse: [^nil].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ArchitecturePrimitive class	instanceVariableNames: ''!!ArchitecturePrimitive class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 12:55'!initialize	Singleton _ nil.! !!ArchitecturePrimitive class methodsFor: 'as yet unclassified' stamp: 'ras 5/6/2005 15:44'!instance	Singleton isNil ifTrue: [		Singleton _ self new.	].	^Singleton		! !Object subclass: #BehaviorSpec	instanceVariableNames: 'type properties quality'	classVariableNames: 'BehaviorUnknown'	poolDictionaries: ''	category: 'QuA'!!BehaviorSpec commentStamp: 'ras 5/23/2005 13:42' prior: 0!This class specifies behavioral aspects of a QuA service.Structure: type		a QuAObject -- reference to object defining (ideal) service functionality properties	a ScvMap -- parameter values for customizable service types quality		a QualitySpec -- specifies utility as function of error (deviation from ideal)!!BehaviorSpec methodsFor: 'accessing' stamp: 'ras 6/3/2005 18:32'!match: spec	"If this BehaviorSpec could conform to spec, return a copy specialized to match."	| copy |	copy _ spec shallowCopy.	copy properties: spec properties copy.	"copy should inherit properties of both self and spec unless there is a conflict"	self properties keysAndValuesDo: [ :key :value |		(spec properties includesKey: key)			ifTrue: [ (spec properties at: key) = value ifFalse: [^nil]. ].		copy properties at: key put: value.	].	spec properties keysAndValuesDo: [ :key :value |		(self properties includesKey: key)			ifTrue: [ (self properties at: key) = value ifFalse: [^nil]. ].		copy properties at: key put: value.	].	copy quality: spec quality copy.		"always copy from spec quality"	^copy.! !!BehaviorSpec methodsFor: 'accessing' stamp: 'ras 5/23/2005 16:53'!objectForDataStream: refStrm    "Return an object to store on an external data stream."    (QuA isQuAProxy: type)		ifTrue: [ ^self. ]		ifFalse: [ ^self copy type: (QuAObject for: type). ].! !!BehaviorSpec methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:04'!properties	^properties! !!BehaviorSpec methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:04'!properties: anObject	properties := anObject! !!BehaviorSpec methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:04'!quality	^quality! !!BehaviorSpec methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:04'!quality: anObject	quality := anObject! !!BehaviorSpec methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:04'!type	^type! !!BehaviorSpec methodsFor: 'accessing' stamp: 'ras 5/5/2005 11:04'!type: anObject	type := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BehaviorSpec class	instanceVariableNames: ''!!BehaviorSpec class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 12:49'!initialize	BehaviorUnknown _ nil.		! !!BehaviorSpec class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 12:31'!type: aType	^self unknown copy		type: aType.		! !!BehaviorSpec class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 12:08'!unknown	BehaviorUnknown isNil ifTrue: [		BehaviorUnknown _ self new			type: QuA typeAny;			properties: SvcMap none;			quality: QualitySpec unknown.	].	^BehaviorUnknown		! !Object subclass: #BindingSpec	instanceVariableNames: 'name obj local input setter bind sender propertySelector receiver'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!BindingSpec commentStamp: 'ras 9/22/2003 14:25' prior: 0!Responsible for remembering the different components of a binding specification.!!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 17:30'!bind	^bind! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 17:30'!bind: aBoolean	bind _ aBoolean! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 14:09'!input	^input! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 10:47'!input: aBoolean	input _ aBoolean! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 14:09'!local	^local! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 10:47'!local: aBoolean	local _ aBoolean! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 14:09'!name	^name! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 10:46'!name: aString	name _ aString! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 14:10'!obj	^obj! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 10:46'!obj: anObj	obj _ anObj! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 9/22/2003 13:18'!sender: senderQuAName property: aSelector receiver: receiverQuAName	sender _ senderQuAName.	propertySelector _ aSelector.	receiver _ receiverQuAName.! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 14:10'!setter	^setter! !!BindingSpec methodsFor: 'initialization' stamp: 'ras 12/7/2004 10:46'!setter: aString	setter _ aString! !!BindingSpec methodsFor: 'access' stamp: 'ras 9/22/2003 13:19'!propertySelector	^propertySelector.! !!BindingSpec methodsFor: 'access' stamp: 'ras 9/22/2003 13:19'!receiver	^receiver.! !!BindingSpec methodsFor: 'access' stamp: 'ras 9/22/2003 13:18'!sender	^sender.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BindingSpec class	instanceVariableNames: ''!!BindingSpec class methodsFor: 'as yet unclassified' stamp: 'ras 12/7/2004 10:44'!interface: aString localObj: anObj	^super new		name: aString;		input: false;		local: true;		obj: anObj;		yourself.! !!BindingSpec class methodsFor: 'as yet unclassified' stamp: 'ras 12/7/2004 10:44'!interface: aString localObj: anObj setterString: anotherString	^super new		name: aString;		input: true;		local: true;		obj: anObj;		setter: anotherString;		yourself.! !!BindingSpec class methodsFor: 'as yet unclassified' stamp: 'ras 12/7/2004 17:13'!localClient	^super new		name: 'client';		obj: QuA thisCapsule;		bind: false;		input: true;		local: true;		yourself.! !!BindingSpec class methodsFor: 'as yet unclassified' stamp: 'ras 12/7/2004 10:36'!localInput: anArray	^self 		interface: anArray first		localObj: (anArray at: 2)		setterString: (anArray at: 3).! !!BindingSpec class methodsFor: 'as yet unclassified' stamp: 'ras 12/7/2004 10:37'!localOutput: anArray	^self 		interface: anArray first		localObj: (anArray at: 2).! !!BindingSpec class methodsFor: 'as yet unclassified' stamp: 'ras 9/22/2003 13:16'!sender: senderQuAName property: aSelector receiver: receiverQuAName	^super new		sender: senderQuAName property: aSelector receiver: receiverQuAName;		yourself.! !Object subclass: #ErrorBudgetor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!ErrorBudgetor commentStamp: 'ras 9/22/2003 14:41' prior: 0!Responsible for mapping a service error budget, which is a set of acceptable error limits for a service, into a set of subservice error budgets: one for each subservice that is to implement the service.An ErrorBudgetor must understand how error in the service is derived from error in the subservices and ensure that if the subservices stay within their respective budgets, the service will stay within its budget.!!ErrorBudgetor methodsFor: 'calculation' stamp: 'ras 6/11/2003 16:19'!budgetFor: aQualitySpec in: aServiceContext	"may consider service context resources and implementation knowledge to return collection of errorBounds for each component, that, if satisfied by components, will satisfy aQualitySpec for the composition."	self subclassResponsibility! !Object subclass: #ErrorModel	instanceVariableNames: 'dimensions'	classVariableNames: 'Unknown'	poolDictionaries: ''	category: 'QuA'!!ErrorModel methodsFor: 'comparison' stamp: 'ras 9/29/2004 19:12'!= anErrorModel	| other |	other _ anErrorModel dimensions.	(dimensions size = other size) ifFalse: [^false.].	1 to: dimensions size do: [ :i |		((dimensions at: i) = (other at: i)) ifFalse: [^false.].	].	^true! !!ErrorModel methodsFor: 'comparison' stamp: 'ras 5/30/2005 14:56'!hash	| allMyDimensions |	allMyDimensions _ WriteStream on: String new.	dimensions do: [ :d | allMyDimensions nextPutAll: d. ].	^allMyDimensions contents hash.! !!ErrorModel methodsFor: 'access' stamp: 'ras 9/17/2004 20:41'!dimensions	^dimensions! !!ErrorModel methodsFor: 'initialization' stamp: 'ras 9/17/2004 20:41'!dimensions: collectionOfNames	dimensions _ collectionOfNames! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ErrorModel class	instanceVariableNames: ''!!ErrorModel class methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 14:44'!dimensions: aCollection	^self new dimensions: aCollection! !!ErrorModel class methodsFor: 'as yet unclassified' stamp: 'ras 5/23/2005 21:11'!initialize	Unknown _ nil.! !!ErrorModel class methodsFor: 'as yet unclassified' stamp: 'ras 5/23/2005 21:11'!unknown	Unknown ifNil: [		Unknown _ self new			dimensions: {}.	].	^Unknown.! !Object subclass: #ErrorPredictor	instanceVariableNames: 'myErrorModel'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!ErrorPredictor commentStamp: 'ras 9/22/2003 14:43' prior: 0!Responsible for estimating error limits for an implementation if it is instantiated in a given service context.!!ErrorPredictor methodsFor: 'calculation' stamp: 'ras 5/16/2005 14:30'!errorForPlatform: platformSvcMirror andComponents: aSvcMap	^self subclassResponsibility! !!ErrorPredictor methodsFor: 'calculation' stamp: 'ras 5/16/2005 15:03'!errorModel	^myErrorModel! !!ErrorPredictor methodsFor: 'calculation' stamp: 'ras 9/29/2004 17:54'!errorModel: anErrorModel	myErrorModel _ anErrorModel! !Object subclass: #InputSpec	instanceVariableNames: 'interface properties'	classVariableNames: 'Unknown'	poolDictionaries: ''	category: 'QuA'!!InputSpec methodsFor: 'initialize' stamp: 'ras 9/17/2004 20:47'!interface: aQuAName	interface _ aQuAName! !!InputSpec methodsFor: 'initialize' stamp: 'ras 9/17/2004 20:47'!properties: aPropertyMap	properties _ aPropertyMap! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InputSpec class	instanceVariableNames: ''!!InputSpec class methodsFor: 'as yet unclassified' stamp: 'ras 5/23/2005 21:15'!initialize	Unknown _ nil.! !!InputSpec class methodsFor: 'as yet unclassified' stamp: 'ras 5/23/2005 21:14'!unknown	Unknown ifNil: [		Unknown _ self new			interface: QuA typeAny;			properties: SvcMap none.	].	^Unknown! !Object subclass: #QoSRelations	instanceVariableNames: 'errorAllocator errorPredictor'	classVariableNames: 'Unknown'	poolDictionaries: ''	category: 'QuA'!!QoSRelations methodsFor: 'accessing' stamp: 'ras 5/5/2005 13:57'!errorAllocator	^errorAllocator! !!QoSRelations methodsFor: 'accessing' stamp: 'ras 5/5/2005 13:57'!errorAllocator: anObject	errorAllocator := anObject! !!QoSRelations methodsFor: 'accessing' stamp: 'ras 5/5/2005 13:57'!errorPredictor	^errorPredictor! !!QoSRelations methodsFor: 'accessing' stamp: 'ras 5/5/2005 13:57'!errorPredictor: anObject	errorPredictor := anObject! !!QoSRelations methodsFor: 'accessing' stamp: 'ras 6/3/2005 18:23'!match: spec	"match only if spec qosRelations unspecified or same as self"	spec = QoSRelations unknown ifTrue: [^self copy].	self = spec ifTrue: [^self copy].	^nil.! !!QoSRelations methodsFor: 'accessing' stamp: 'ras 5/23/2005 16:26'!objectForDataStream: refStrm    "Return an object to store on an external data stream."    ^self copy 		errorPredictor: (QuAObject for: errorPredictor);		errorAllocator: (QuAObject for: errorAllocator).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QoSRelations class	instanceVariableNames: ''!!QoSRelations class methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 15:12'!errorPredictor: anErrorPredictor	^self new		errorPredictor: anErrorPredictor;		yourself! !!QoSRelations class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 12:57'!initialize	Unknown _ nil.! !!QoSRelations class methodsFor: 'as yet unclassified' stamp: 'ras 5/11/2005 18:48'!unknown	Unknown isNil ifTrue: [		Unknown _ self new.	].	^Unknown		! !Object subclass: #QuA	instanceVariableNames: ''	classVariableNames: 'Any CapsuleSingleton QuAPlatformSingleton ServiceContexts'	poolDictionaries: ''	category: 'QuA'!!QuA commentStamp: 'ras 9/23/2004 15:46' prior: 0!The global identifier "QuA" is used to access the QuAMOP interfaces.  These interfaces support the following uses of the platform:- component-development:  the platform is responsible for publishing new component blueprints.- reflection-on-application:  instantiation and composition of application objects, introspection on application objects.- reflection-on-platform:  getting the current service context to change how platform services (including reflection on application) are implemented.Additional convenience methods provide a concise way to express common method invocations.This class provides the meta-object protocol for access to meta objects, i.e., to instances of QuA core types.Here are general rules used in this prototype for mapping QuA PIM interface, operation, type, and argument names to Smalltalk syntax:	A PIM interface named IMyClassMyCategory corresponds to an instance method category named MyCategory in the class MyClass.	One exception to this rule is the interfaces with the prefix IQuAMOP are implemented by *class* method categories in the class QuA.	A PIM operation named myOperation with arguments MyType1 myArg1, MyType2 myArg2, etc., are implemented by a method with selector #myOperationMyArg1:myArg2:, etc.	!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuA class	instanceVariableNames: ''!!QuA class methodsFor: 'component development' stamp: 'ras 5/5/2005 12:21'!advertise: anObject	QuA thisServiceContext implementationBroker advertise: anObject! !!QuA class methodsFor: 'component development' stamp: 'ras 5/20/2005 23:53'!publish: anObject name: aString	| persistentStore aQuAName |	aQuAName _ QuAName fromString: aString.	persistentStore := self resolve: aQuAName repositoryQuAName.	"write component to persistent store and associate with aQuAName"	persistentStore at: aQuAName putObj: anObject.	aQuAName		version: (persistentStore versionsAt: aQuAName) size - 1;		fixLevel: 0;		yourself.	^QuAObject named: aQuAName.! !!QuA class methodsFor: 'convenience functions' stamp: 'ras 5/15/2005 13:29'!bind: senderQuAName property: selector to: receiverQuAName 	^QuA bind: senderQuAName property: selector to: receiverQuAName withQuality: QualitySpec unknown.! !!QuA class methodsFor: 'convenience functions' stamp: 'ras 5/9/2005 21:51'!instanceOf: type	^(QuA instantiate: type) primaryInterface! !!QuA class methodsFor: 'convenience functions' stamp: 'ras 5/15/2005 12:09'!instantiate: type	^self 		instantiate: type 		properties: SvcMap none		quality: QualitySpec unknown! !!QuA class methodsFor: 'convenience functions' stamp: 'ras 5/13/2005 10:01'!isQuAProxy: anObject	^anObject respondsTo: #metaQuAName.! !!QuA class methodsFor: 'convenience functions' stamp: 'ras 5/15/2005 13:27'!resolve: aQuAName	^self resolve: aQuAName withQuality: QualitySpec unknown.! !!QuA class methodsFor: 'reflection on application' stamp: 'ras 5/23/2005 15:35'!bind: anObject property: selector to: receiverObject withQuality: extraFunctionalSpec 	| repository |	(QuA isQuAProxy: anObject)		ifTrue: [ repository _ QuA resolve: anObject metaQuAName repositoryQuAName. ]		ifFalse: [ repository _ QuA thisCapsule defaultRepository. ].			repository 		bindLocal: anObject 		property: (selector,':') asSymbol 		to: receiverObject 		withQuality: extraFunctionalSpec.! !!QuA class methodsFor: 'reflection on application' stamp: 'ras 6/5/2005 18:01'!bindingFor: anObject withQuality: extraFunctionalSpec	| |	(QuA isQuAProxy: anObject)		ifFalse: [ ^anObject. ].	"return reference to local object"	^(ServiceMirror			type: '/QuA/capability' qua			properties: (SvcMap fromValues: { 'receiver'->anObject. })			quality: extraFunctionalSpec)		 run primaryInterface.  "result is a local proxy object"! !!QuA class methodsFor: 'reflection on application' stamp: 'ras 5/12/2005 21:55'!instantiate: type properties: anSvcMap quality: aQualitySpec	| svcMirror |	svcMirror _ ServiceMirror type: type properties: anSvcMap quality: aQualitySpec.	^svcMirror run.! !!QuA class methodsFor: 'reflection on application' stamp: 'ras 6/1/2005 16:39'!instantiate: bindings with: components	| interfaces |	interfaces _ OrderedCollection new.	bindings do: 		[:binding | 			interfaces add: (components at: binding sender).			QuA 				bind: (components at: binding sender) primaryInterface				property: binding propertySelector				to: (components at: binding receiver) primaryInterface				withQuality: QualitySpec unknown.		].	^interfaces! !!QuA class methodsFor: 'reflection on application' stamp: 'ras 5/27/2005 23:51'!nameFor: anObject	"return QuAName for anObject"	| quaName |	(QuA isQuAProxy: anObject)		ifTrue: [ ^anObject metaQuAName. ].			quaName _ QuA thisCapsule quaNameFor: anObject.	quaName ifNotNil: [^quaName].		^QuA thisCapsule registerAsQuA: anObject.! !!QuA class methodsFor: 'reflection on application' stamp: 'ras 5/28/2005 11:19'!objFor: aQuAName	"return object reference for aQuAName"	| obj |	obj _ QuA thisCapsule quaObjAt: aQuAName.	obj notNil ifTrue: [ ^obj ].		^QuAObject named: aQuAName! !!QuA class methodsFor: 'reflection on application' stamp: 'ras 5/13/2005 10:04'!reflectOn: anObject	| mirror |	mirror _ self thisCapsule mirrorFor: anObject.	mirror notNil ifTrue: [ ^mirror ].		(QuA isQuAProxy: anObject)		ifTrue: [ ^ServiceMirror implementation: anObject. ].	^ServiceMirror 		type: (QuA thisCapsule quaTypeFor: anObject) 		primitive: anObject.! !!QuA class methodsFor: 'reflection on application' stamp: 'ras 5/29/2005 10:23'!repositoryFor: anObject	"return repository for anObject"			(QuA isQuAProxy: anObject) ifFalse: [^QuA thisCapsule defaultRepository.].		^QuA resolve: (QuA nameFor: anObject) repositoryQuAName.! !!QuA class methodsFor: 'reflection on application' stamp: 'ras 5/9/2005 21:31'!resolve: aQuAName withQuality: extraFunctionalSpec	^QuA bindingFor: (QuA objFor: aQuAName) withQuality: extraFunctionalSpec! !!QuA class methodsFor: 'squeak prototype' stamp: 'ras 5/15/2005 13:05'!initializeWithName: repositoryNameString	| classes |	classes _ SystemOrganization superclassOrder: 'QuA'.	classes remove: self.	classes do: [ :eachClass |		(eachClass respondsTo: #initialize) ifTrue: [			eachClass initialize.		].	].	ServiceContexts _ Dictionary new.	CapsuleSingleton _ SqueakCapsule new.	CapsuleSingleton initializeWithName: repositoryNameString.	Any _ '/QuA/type/any' qua.! !!QuA class methodsFor: 'squeak prototype' stamp: 'ras 5/15/2005 13:34'!inputSpec	^InputSpec unknown copy! !!QuA class methodsFor: 'squeak prototype' stamp: 'ras 5/23/2005 22:00'!platformInitialize	self initializeWithName: '/temp'.! !!QuA class methodsFor: 'squeak prototype' stamp: 'ras 5/15/2005 13:33'!qualitySpec	^QualitySpec unknown copy! !!QuA class methodsFor: 'squeak prototype' stamp: 'ras 4/15/2004 12:52'!typeAny	Any ifNil: [ self initialize ].	^Any! !!QuA class methodsFor: 'squeak prototype' stamp: 'ras 5/15/2005 13:36'!utilityFunction	^UtilityFunction unknown copy! !!QuA class methodsFor: 'reflection on platform' stamp: 'ras 5/13/2005 10:55'!thisCapsule	^CapsuleSingleton! !!QuA class methodsFor: 'reflection on platform' stamp: 'ras 5/20/2004 14:21'!thisServiceContext	"use active process to find associated service context"	ServiceContexts 		at: Processor activeProcess 		ifAbsent: [ ^self thisCapsule defaultServiceContext ].! !!QuA class methodsFor: 'reflection on platform' stamp: 'ras 5/26/2003 19:48'!version	^'QuA 1.0'! !Object subclass: #QuABroker	instanceVariableNames: 'availableRepositories activeServices inactiveServices factoryPlans'	classVariableNames: 'MyFileName Singleton'	poolDictionaries: ''	category: 'QuA'!!QuABroker commentStamp: 'ras 5/24/2005 13:13' prior: 0!Maps a QuAType to a set of ServiceMirror objects; each represents an alternative implementation of the service type.  The invariant goal of this class is to provide access to every advertised plan (ServiceMirror) that does not depend on an obsolete or unavailable resource.To satisfy the invariant, this implementation monitors the availability of repositories throughout the network, activating advertisements when the repositories referenced become accessible, and deactivating advertisements when any referenced repository becomes inaccessible.  When volatile repositories are shutdown, the advertisements that reference resources in those repositories may be permanently forgotten.The QuA ImplementationBroker is used to advertise alternative implementations.  For example, when a blueprint is published, the ImplementationBroker #advertise method may be called to associate the type of service whose implementation is specified by the blueprint with a plan to instantiate the blueprint on the appropriate platform.  If the blueprint specifies implementation of a factory (e.g., a class with support for instance creation), #advertise must be invoked again to associate the instance type with a plan to create the instance from the factory.  In this last advertisement, the factory type is specified as the platform for creating instances, but no architecture or implementation are given, since these can be found automatically from the blueprint advertised earlier.!!QuABroker methodsFor: 'discovery' stamp: 'ras 5/29/2005 10:11'!activateViableAdvertisements	| setToActivate |	setToActivate _ inactiveServices select: [ :each |		availableRepositories includesAllOf: each repositoryDependencies.	].	setToActivate do: [ :each |		inactiveServices remove: each.		activeServices add: each.	].! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/24/2005 15:46'!advertise: aServiceMirror	"associate this new software component version with typeName"	| alternatives type |	type _ aServiceMirror behavior type.	alternatives _ activeServices at: type 		ifAbsent: [ 			alternatives _ OrderedCollection new. 			activeServices at: type put: alternatives. 			alternatives. 		].	alternatives add: aServiceMirror.! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/29/2005 21:46'!deactivateAdvertisementsReferringTo: aRepository save: saveFlag	(activeServices select: [ :svc | svc repositoryDependencies includes: aRepository. ])		do: [ :obsoleteSvc | 			activeServices remove: obsoleteSvc.			saveFlag ifTrue: [ inactiveServices add: obsoleteSvc. ].		].! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/31/2005 13:30'!garbageCollect	"remove advertisements for volatile repository resources"	QuA thisCapsule locallyHostedRepositories do: [ :rep |		(rep isKindOf: VolatileRepository)			ifTrue: [ self notifyTerminated: rep. ]			ifFalse: [ self notifyUnavailable: rep. ].	].! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/31/2005 13:25'!initialize	super initialize.	availableRepositories _ Set new.	activeServices _ Dictionary new.	inactiveServices _ Dictionary new.	factoryPlans _ Dictionary new.	"used for looking up type associated with a factory""	QuA thisCapsule addShutdownBlock: [ self saveState. ]."! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/29/2005 10:09'!notifyAvailable: aRepository	availableRepositories add: aRepository.	self activateViableAdvertisements! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/29/2005 21:44'!notifyTerminated: aRepository	availableRepositories remove: aRepository.	self deactivateAdvertisementsReferringTo: aRepository save: false.! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/29/2005 21:44'!notifyUnavailable: aRepository	availableRepositories remove: aRepository.	self deactivateAdvertisementsReferringTo: aRepository save: true.! !!QuABroker methodsFor: 'discovery' stamp: 'ras 6/3/2005 16:47'!plansFor: spec	| planTemplates matches copy |	planTemplates _ activeServices at: spec behavior type ifAbsent: [#()].	matches _ OrderedCollection new.	planTemplates do: [ :p | 		copy _ p match: spec.		copy ifNotNil: [ matches add: copy ]. 	].	^matches! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/24/2005 23:00'!removeAll: svcMirrorCollection	activeServices associationsDo: [ :each |		each value removeAll: svcMirrorCollection.	].	inactiveServices associationsDo: [ :each |		each value removeAll: svcMirrorCollection.	].! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/29/2005 21:26'!saveState	"before saving, return to initial state where no repositories are available"	availableRepositories _ Set new.	activeServices do: [ :each |		inactiveServices add: each.	].	activeServices _ Dictionary new.	(FileStream forceNewFileNamed: MyFileName) fileOutClass: nil andObject: self.! !!QuABroker methodsFor: 'discovery' stamp: 'ras 5/24/2005 15:31'!typeForFactory: aFactoryType	"this is the reason we keep track of factoryPlans: so we can remember the instance type associated with the factory type."	^factoryPlans at: aFactoryType ifAbsent: [nil].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuABroker class	instanceVariableNames: ''!!QuABroker class methodsFor: 'as yet unclassified' stamp: 'ras 5/24/2005 13:42'!initialize	Singleton _ nil.	MyFileName _ FileDirectory default fullPathFor: 'QuABrokerState'.! !!QuABroker class methodsFor: 'as yet unclassified' stamp: 'ras 5/31/2005 13:24'!instance	Singleton ifNil: ["		[Singleton _ (FileStream oldFileNamed: MyFileName) fileInObjectAndCode.] ifError: []."		Singleton ifNil: [ Singleton _ self new. ].	].	^Singleton.! !Architecture subclass: #QuAComposition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!QuAComposition methodsFor: 'configuration' stamp: 'ras 5/9/2005 16:13'!addInstanceOf: aQuAName role: name	componentServices at: name put: (ServiceMirror type: aQuAName)! !!QuAComposition methodsFor: 'configuration' stamp: 'ras 5/5/2005 14:26'!addObject: aQuAName role: aName 	componentServices at: aName put: (QuA reflectOn: aQuAName)! !!QuAComposition methodsFor: 'configuration' stamp: 'ras 5/5/2005 14:00'!set: objectName property: propName to: collaboratorName	blueprint add: (BindingSpec sender: objectName property: propName receiver: collaboratorName)! !!QuAComposition methodsFor: 'private' stamp: 'ras 5/9/2005 14:52'!initialize	super initialize.	self		platform: (QuA reflectOn: QuA);		blueprint: Set new.	"set of component binding specifications"! !Object subclass: #QuAName	instanceVariableNames: 'fromString path shortName version fixLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!QuAName commentStamp: 'ras 9/22/2003 15:31' prior: 0!Responsible for identifying a QuAObject.A QuAName has three main parts:- path is a multi-part name that uniquely identifies the repository where the QuA object can be found.- shortName is the unique identifier for the object within its repository.- version (and fixLevel) is the unique identifier for a particular object version if the object resides in a versioned (persistent) repository.Although untested, the reason for this design is as follows.  Like a web browser accessing a URL, a QuA platform should be able to use the path in a QuAName to locate a remote QuA repository and to bind to an object in that repository.  Unlike URLs, a QuA repository path is not a machine name.  A QuA repository may share the same machine with many other repositories and may move to another machine.  A repository may be replicated also.  The responsibility for avoiding repository name conflicts belongs to the organization that creates a QuA name space.  The responsibility for assuring that repository names are correctly mapped to the correct machine belongs to a repository discovery service.The versioning of names is intended to support safe evolution of component implementations.  Configurations that name the version of an object will be unaffected by other applications that bind to a newer version of the same object.!!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 4/10/2003 21:19'!= aQuAName	^self printString = aQuAName printString! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 1/17/2003 00:01'!fixLevel	^fixLevel! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 4/10/2003 00:11'!fixLevel: anInteger	fixLevel _ anInteger! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 4/24/2003 20:25'!fromString: aString	| i schemeName |	i _ aString findString: '://' startingAt: 1.	i = 0 ifTrue: [ ^self parse: aString startingAt: 1. ].	schemeName _ aString copyFrom: 1 to: i - 1.	schemeName asLowercase = 'http' 		ifTrue: [ ^self error: 'not implemented yet' ]		ifFalse: [ self error: 'unrecognized QuAName scheme: ',schemeName ]! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 5/20/2005 21:46'!fullName	^self repositoryNameString, '/', shortName.! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 5/20/2004 14:10'!hash	"required to allow efficient lookup by QuAName in a Dictionary"	^self printString hash! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 1/17/2003 00:00'!path	^path! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 2/26/2003 19:11'!path: anOrderedCollectionOfString	path _ anOrderedCollectionOfString! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 5/20/2005 21:46'!printString	fromString isNil ifTrue: [ fromString _ 'qua:',self fullName,':',version asString,'.',fixLevel asString. ].	^fromString! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 6/11/2003 15:13'!repository: aQuAName	path _ aQuAName path copy.	path add: aQuAName shortName.! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 5/14/2003 18:54'!repositoryNameString	| name |	path size = 0 ifTrue: [^''].	name _ String new.	path do: [:element | 		name _ name, '/', element.	].	^name! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 6/11/2003 22:46'!repositoryQuAName	path size > 0		ifTrue: [ ^QuAName forRepositoryPath: path. ]		ifFalse: [ ^self ].! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 1/17/2003 00:00'!shortName	^shortName! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 2/26/2003 19:10'!shortName: aString	shortName _ aString! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 1/17/2003 00:00'!version	^version! !!QuAName methodsFor: 'as yet unclassified' stamp: 'ras 4/10/2003 00:10'!version: anInteger	version _ anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuAName class	instanceVariableNames: ''!!QuAName class methodsFor: 'as yet unclassified' stamp: 'ras 4/11/2003 01:09'!forRepositoryPath: aPath	| quaName |	quaName _ self new.	quaName path: aPath copy.	quaName path size < 1		ifTrue: [ quaName shortName: ''. ]		ifFalse: [ quaName shortName: (quaName path removeLast). ].	quaName version: 0.	quaName fixLevel: 0.	^quaName! !!QuAName class methodsFor: 'as yet unclassified' stamp: 'ras 5/14/2003 18:23'!fromString: aString	| i schemeName |	i _ aString findString: ':/' startingAt: 1.	i = 0 ifTrue: [ ^self parse: aString startingAt: 1. ].	schemeName _ aString copyFrom: 1 to: i - 1.	schemeName asLowercase = 'http' 		ifTrue: [ ^self error: 'not implemented yet' ].	schemeName asLowercase = 'qua'		ifTrue: [ ^self parse: aString startingAt: i. ]		ifFalse: [ self error: 'unrecognized QuAName scheme: ',schemeName ]! !!QuAName class methodsFor: 'as yet unclassified' stamp: 'ras 5/4/2003 12:50'!parse: quANameString startingAt: start	| quaName i j |	quaName _ self new.	i _ start.	j _ quANameString findString: '/' startingAt: i.	quaName path: OrderedCollection new.	[ j ~= 0 ] whileTrue: [		i _ j + 1.		j _ quANameString findString: '/' startingAt: i.		j ~= 0 ifTrue: [ quaName path add: (quANameString copyFrom: i to: j-1). ].	].	j _ quANameString findString: ':' startingAt: i.	j = 0 		ifTrue: [ 			quaName shortName: (quANameString copyFrom: i to: quANameString size). 			quaName version: 0.			quaName fixLevel: 0.		] ifFalse: [ 			quaName shortName: (quANameString copyFrom: i to: j-1). 			i _ j + 1.			j _ quANameString findString: '.' startingAt: i.			j = 0 ifTrue: [ self error: 'bad version.fix format'. ].			quaName version: (quANameString copyFrom: i to: j-1) asInteger.			quaName fixLevel: (quANameString copyFrom: j+1 to: quANameString size) asInteger. 		].	^quaName! !Object subclass: #QuAObject	instanceVariableNames: 'quaName'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!QuAObject methodsFor: 'as yet unclassified' stamp: 'ras 5/13/2005 10:00'!= anObject	(QuA isQuAProxy: anObject)		ifTrue: [ ^quaName = anObject metaQuAName. ].	^self doesNotUnderstand: (Message selector: #= argument: anObject).! !!QuAObject methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 14:10'!doesNotUnderstand: aMessage	| binding |	binding _ QuA resolve: quaName.	self becomeForward: binding.	^binding perform: aMessage selector withArguments: aMessage arguments! !!QuAObject methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 14:52'!hash	^quaName hash! !!QuAObject methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 10:34'!metaQuAName	^quaName! !!QuAObject methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 10:34'!metaQuAName: aQuAName	quaName _ aQuAName! !!QuAObject methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 11:32'!printString	^'a ',self class name,' on ',quaName printString.! !!QuAObject methodsFor: 'as yet unclassified' stamp: 'ras 5/29/2005 12:24'!readDataFrom: aDataStream size: varsOnDisk	"this method is same as if inherited from Object"	| localObj |	aDataStream beginReference: self.	1 to: varsOnDisk do:		[:i | self instVarAt: i put: aDataStream next].	localObj _ QuA thisCapsule quaObjAt: quaName.	localObj ifNotNil: [ ^localObj. ].	^self.! !!QuAObject methodsFor: 'as yet unclassified' stamp: 'ras 6/6/2005 14:27'!size	"don't let superclass handle, this message must go to my remote object."	^self doesNotUnderstand: (Message selector: #size)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuAObject class	instanceVariableNames: ''!!QuAObject class methodsFor: 'as yet unclassified' stamp: 'ras 5/23/2005 16:20'!for: anObject	anObject class = self ifTrue: [^anObject].	^self named: (QuA nameFor: anObject).! !!QuAObject class methodsFor: 'as yet unclassified' stamp: 'ras 5/10/2005 10:35'!named: aQuAName	^self new metaQuAName: aQuAName! !Object subclass: #QualitySpec	instanceVariableNames: 'errorModel inputGuarantee utilityFunction'	classVariableNames: 'Singleton'	poolDictionaries: ''	category: 'QuA'!!QualitySpec commentStamp: 'ras 9/22/2003 16:00' prior: 0!Responsible for specifying how service utility (usefulness) depends on error in service outputs.The QuA reflection-on-application interface allows a client to provide a QualitySpec for service creation.  If trying to derive QoS guarantees for a service a service planner can ask a QualitySpec for ErrorBounds to be used in selecting acceptable service implementation components.  A planner can then ask an ErrorBudgetor associated with a service implementation for acceptable subservice ErrorBounds.  For any candidate subservice implementation, a planner can ask the associated ErrorEstimator for an estimate of ErrorBounds and can use the QualitySpec utility function to compute utility from these ErrorBounds.The service planner may provide a QualitySpec to an adaptive component implementation so that adaptation can achieve the highest utility.!!QualitySpec methodsFor: 'calculation' stamp: 'ras 9/20/2004 16:08'!errorModel	^errorModel! !!QualitySpec methodsFor: 'calculation' stamp: 'ras 9/17/2004 20:44'!errorModel: anErrorModel	errorModel _ anErrorModel.! !!QualitySpec methodsFor: 'calculation' stamp: 'ras 9/17/2004 20:18'!inputGuarantee: inputSpec	inputGuarantee _ inputSpec.! !!QualitySpec methodsFor: 'calculation' stamp: 'ras 5/15/2005 13:50'!utility: aUtilityFunction	utilityFunction _ aUtilityFunction! !!QualitySpec methodsFor: 'calculation' stamp: 'ras 9/20/2004 15:59'!utilityFunction	^utilityFunction! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QualitySpec class	instanceVariableNames: ''!!QualitySpec class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 13:00'!initialize	Singleton _ nil.! !!QualitySpec class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 12:11'!unknown	Singleton isNil ifTrue: [			Singleton _ self new				errorModel: ErrorModel unknown;				inputGuarantee: InputSpec unknown;				utility: UtilityFunction unknown.		].	^Singleton! !Object subclass: #Repository	instanceVariableNames: 'repositoryName capsule'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!Repository commentStamp: 'ras 3/21/2003 14:31' prior: 0!Map QuANames to QuAObjects!!Repository methodsFor: 'access' stamp: 'ras 5/23/2005 16:54'!at: aQuAName putObj: anObject	self subclassResponsibility! !!Repository methodsFor: 'access' stamp: 'ras 4/25/2005 16:53'!quaObjAt: aQuAName 	"return just the object (and version) named aQuAName"	self subclassResponsibility! !!Repository methodsFor: 'access' stamp: 'ras 4/25/2005 15:43'!versionsAt: aQuAName 	"return all versions of aQuAName"	self subclassResponsibility! !!Repository methodsFor: 'reflection' stamp: 'ras 5/9/2005 22:02'!bindLocal: sender property: selector to: receiver withQuality: extraFunctionalSpec 	| |	sender perform: selector withArguments: { QuA bindingFor: receiver withQuality: extraFunctionalSpec. }.! !!Repository methodsFor: 'reflection' stamp: 'ras 9/10/2004 22:48'!capsule	^capsule! !!Repository methodsFor: 'reflection' stamp: 'ras 5/10/2005 14:09'!quaName	^repositoryName.! !!Repository methodsFor: 'initialization' stamp: 'ras 4/29/2003 16:19'!capsule: aCapsule	capsule _ aCapsule.! !!Repository methodsFor: 'initialization' stamp: 'ras 6/6/2005 14:32'!instantiate: classSource with: componentServices	^capsule instantiate: classSource with: componentServices! !!Repository methodsFor: 'initialization' stamp: 'ras 5/29/2005 11:12'!objectForDataStream: refStrm    "Return an object to store on an external data stream."    ^QuAObject named: (QuA nameFor: self).! !!Repository methodsFor: 'initialization' stamp: 'ras 6/11/2003 14:25'!quaName: aQuAName	repositoryName _ aQuAName.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Repository class	instanceVariableNames: ''!!Repository class methodsFor: 'as yet unclassified' stamp: 'ras 6/6/2005 14:38'!named: aString	^self new		quaName: aString asQuAName;		capsule: QuA thisCapsule! !Repository subclass: #FileBasedRepository	instanceVariableNames: 'directory'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!FileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ras 5/20/2005 23:07'!at: aQuAName putObj: anObject	"persistently store anObject with the associated name"	| writeStream |	writeStream _ FileStream forceNewFileNamed: (directory fullNameFor: aQuAName shortName).	anObject storeOn: writeStream.	writeStream close.! !!FileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ras 6/7/2005 11:35'!quaName: aQuAName	super quaName: aQuAName.	directory _ FileDirectory default.	aQuAName path do: [ :eachSubDir | directory _ directory directoryNamed: eachSubDir. ].	directory _ 	directory directoryNamed: aQuAName shortName.	directory assureExistence.! !!FileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ras 5/20/2005 23:02'!quaObjAt: aQuAName 	"return persistent object associated with aQuAName"	| readStream obj |	readStream _ FileStream oldFileOrNoneNamed: (directory fullNameFor: aQuAName shortName).	readStream ifNil: [ ^nil. ].	obj _ Object readFrom: readStream reset.	readStream close.	^obj! !!FileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ras 6/7/2005 11:43'!versionsAt: aSoftwareComponentName 	"this class does not yet support multiple versions"	| obj |	obj _ self quaObjAt: aSoftwareComponentName.	obj notNil		ifTrue: [ ^Array with: obj. ]		ifFalse: [ ^Array new. ]. ! !Object subclass: #ServiceContext	instanceVariableNames: 'planner capsule implementationBroker'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!ServiceContext commentStamp: 'ras 9/22/2003 16:06' prior: 0!Provides access to meta objects associated with a service.  In particular, the service context has a service planner, an implementation planner and a binding planner for platform managed QoS.  These may be replaced with specialized planners to optimize QoS management for a particular application.  A new service context may be created for a service with its own QoS requirements.!!ServiceContext methodsFor: 'accessing' stamp: 'ras 3/5/2003 06:29'!capsule	^capsule! !!ServiceContext methodsFor: 'accessing' stamp: 'ras 1/28/2004 11:38'!implementationBroker	^implementationBroker! !!ServiceContext methodsFor: 'accessing' stamp: 'ras 5/24/2005 15:23'!planner	^planner! !!ServiceContext methodsFor: 'initialization' stamp: 'ras 3/5/2003 06:29'!capsule: c	capsule _ c! !!ServiceContext methodsFor: 'initialization' stamp: 'ras 1/28/2004 11:39'!implementationBroker: anObject	implementationBroker := anObject! !!ServiceContext methodsFor: 'initialization' stamp: 'ras 5/24/2005 15:23'!planner: anObject	planner := anObject! !Object subclass: #ServiceMirror	instanceVariableNames: 'behavior architecture interfaces state'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!ServiceMirror commentStamp: 'ras 5/16/2005 10:02' prior: 0!A ServiceMirror holds provides the MOP for a QuA service.  There is no QuA service class, as a service is implemented by one or more concrete instances of base level classes.  In addition, a service may be distributed, so that the ServiceMirror references implementation objects that are remote.The QuA service model includes the following aspects:Behavioral specification    - type:  Supports reflection on functional behavior of service.    - properties: A map from names to ServiceMirrors.  Properties 	are client customizable initialization attributes. The ServiceMirror 	specifies the type and default implementation of a property. An 	architecture for this Behavior specification must include the properties 	among its componentServices.  Properties are used to define a 	parameterized type.    - quality: input guarantee, error model, utility function.Architecture (implementation) specification    - platform: Creates service from blueprint and dependency map.    - blueprint: Architectural specification, format depends on	platform.  E.g., could be QuA composition, or Java class.    - componentServices: Map from name to ServiceMirror.  Component	services are initialization arguments used to assemble (construct)	the implementation.  These include configuration of the properties	specified in the behavior.  Note that componentServices creates a 	recursive structure; a given component may resolve to a service 	in any implementation state.    - compositional QoS relations:  error model, error allocation and      error prediction functions.Implementation access    - interfaces:  As defined by the type, these are runtime objects      that implement the base level interfaces of the service.  This      feature allows that a service may have multiple, distributed      interfaces.    - state: : specified, architected, provisioned, assembled, or running.  	It seems that we will want to reflect on this life cycle to efficiently	govern service planning, both for instantiation and reconfiguration.!!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 19:08'!= aServiceMirror	self == aServiceMirror ifTrue: [ ^true. ].	^self state equivalent: aServiceMirror with: self.! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 22:51'!assemble	^state assemble: self			! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 22:51'!destroy	^state destroy: self			! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 22:02'!match: spec	"If this service could implement that specified in aServiceMirror, return a copy specialized to match the specification."	| copy |	(self state < spec state) ifTrue: [^nil].	copy _ spec shallowCopy.	copy behavior: (self behavior match: spec behavior).	copy behavior ifNil: [^nil].	spec isArchitected		ifTrue: [ copy architecture: (self architecture match: spec architecture). ]		ifFalse: [ copy architecture: (self architecture copy). ].	copy architecture ifNil: [^nil].	copy interfaces: self interfaces copy.	copy state: self state.	^copy.! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 19:02'!objectForDataStream: refStrm    "Return an object to store on an external data stream."	| interfacesCopy |	interfacesCopy _ self interfaces copy.	1 to: interfaces size do: [ :i |		interfacesCopy at: i put: (QuAObject for: (interfaces at: i)). 	].    ^self copy 		interfaces: (interfacesCopy).! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 22:51'!plan	^state plan: self			! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 21:55'!primaryInterface	self assemble.	^interfaces first! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 22:52'!provision	^state provision: self			! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 21:56'!repositoryDependencies	^architecture repositoryDependencies 		addAll: (interfaces collect: [ :intf | QuA repositoryFor: intf. ])! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 22:51'!run	^state run: self			! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 6/3/2005 22:52'!suspend	^state suspend: self			! !!ServiceMirror methodsFor: 'implementation' stamp: 'ras 5/13/2005 11:56'!unresolvedDependencies	^architecture unresolvedDependencies! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 5/5/2005 10:55'!architecture	^architecture! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 5/5/2005 10:55'!architecture: anObject	architecture := anObject! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 5/5/2005 10:55'!behavior	^behavior! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 5/5/2005 10:57'!behavior: anObject	behavior _ anObject! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 5/16/2005 14:25'!errorFor: anErrorModel	self provision.	"make sure we have identified subservices"	^architecture errorFor: anErrorModel! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 6/3/2005 19:04'!interfaces	^interfaces! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 6/3/2005 19:04'!interfaces: anObject	interfaces _ anObject! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 6/3/2005 21:56'!isArchitected	^state >= ServiceArchitected state.! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 6/3/2005 21:56'!isAssembled	^state >= ServiceAssembled state.! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 6/3/2005 21:56'!isProvisioned	^state >= ServiceProvisioned state.! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 6/3/2005 21:58'!isRunning	^state >= ServiceRunning state.! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 6/3/2005 21:57'!isSpecified	^state >= ServiceSpecified state.! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 6/3/2005 19:04'!state	^state! !!ServiceMirror methodsFor: 'accessing' stamp: 'ras 6/3/2005 19:04'!state: anObject	state _ anObject! !!ServiceMirror methodsFor: 'state transitions' stamp: 'ras 6/3/2005 23:29'!copyFrom: aServiceMirror	^self		architecture: aServiceMirror architecture;		interfaces: aServiceMirror interfaces;		state: aServiceMirror state.! !!ServiceMirror methodsFor: 'state transitions' stamp: 'ras 6/3/2005 23:34'!doAssemble	architecture platform assemble.	architecture componentServices do: [ :each |		each assemble. 	].	interfaces _ (architecture instantiateWith: behavior properties).	state _ ServiceAssembled state.! !!ServiceMirror methodsFor: 'state transitions' stamp: 'ras 6/3/2005 22:35'!doDestroy	architecture _ nil.	interfaces _ Array new: 0.	state _ ServiceSpecified state! !!ServiceMirror methodsFor: 'state transitions' stamp: 'ras 6/3/2005 22:59'!doPlan	| context |	context _ QuA thisServiceContext.	^context planner 		plan: self 		in: context.! !!ServiceMirror methodsFor: 'state transitions' stamp: 'ras 6/3/2005 23:05'!doProvision	architecture platform provision.	architecture componentServices do: [ :each |		each provision.	].	state _ ServiceProvisioned state! !!ServiceMirror methodsFor: 'state transitions' stamp: 'ras 6/3/2005 22:28'!doRun	| platform |	platform _ architecture platform primaryInterface.	(platform respondsTo: #enable:) ifTrue: [ platform enable: self. ].	state _ ServiceRunning state.! !!ServiceMirror methodsFor: 'state transitions' stamp: 'ras 6/3/2005 23:35'!doSuspend	| platform |	platform _ architecture platform primaryInterface.	(platform respondsTo: #disable:) ifTrue: [ platform enable: self. ].	state _ ServiceAssembled state.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServiceMirror class	instanceVariableNames: ''!!ServiceMirror class methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 18:58'!behavior: aBehaviorSpec architecture: anArchitecture interfaces: aCollection state: aServiceState	^self new		behavior: aBehaviorSpec;		architecture: anArchitecture;		interfaces: aCollection;		state: aServiceState.! !!ServiceMirror class methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 18:54'!implementation: anObject	^self new		behavior: BehaviorSpec unknown;		architecture: ArchitecturePrimitive instance;		interfaces: (Array with: anObject);		state: ServiceRunning state.! !!ServiceMirror class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 13:42'!type: aQuAType	^self type: aQuAType properties: SvcMap none quality: QualitySpec unknown! !!ServiceMirror class methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 18:56'!type: aQuAType architecture: anArchitecture	^self new		behavior: (BehaviorSpec type: aQuAType);		architecture: anArchitecture;		interfaces: (Array new: 0);		state: ServiceArchitected state.! !!ServiceMirror class methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 18:55'!type: aQuAType primitive: primaryInterface	^(self type: aQuAType architecture: ArchitecturePrimitive instance)		interfaces: (Array with: primaryInterface);		state: ServiceRunning state.! !!ServiceMirror class methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 18:54'!type: aQuAType properties: aMap architecture: anArchitecture	^self new		behavior: (BehaviorSpec new			type: aQuAType;			properties: aMap;			quality: QualitySpec unknown);		architecture: anArchitecture;		interfaces: (Array new: 0);		state: ServiceArchitected state.! !!ServiceMirror class methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 18:52'!type: aQuAType properties: aMap quality: aQualitySpec	^self new		behavior: (BehaviorSpec new			type: aQuAType;			properties: aMap;			quality: aQualitySpec);		architecture: Architecture unknown;		interfaces: (Array new: 0);		state: ServiceSpecified state.! !!ServiceMirror class methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 18:52'!unknown	^self new		behavior: BehaviorSpec unknown;		architecture: Architecture unknown;		interfaces: (Array new: 0);		state: ServiceSpecified state.! !Object subclass: #ServicePlanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!ServicePlanner commentStamp: 'ras 9/22/2003 14:45' prior: 0!Responsible for selecting a QuA type implementation that satisfies QoS requirements.!!ServicePlanner methodsFor: 'implementation planning' stamp: 'ras 5/30/2005 14:46'!plan: aServiceMirror in: context	self subclassResponsibility! !ServicePlanner subclass: #BasicServicePlanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!BasicServicePlanner commentStamp: 'ras 9/22/2003 14:18' prior: 0!Plays roles of ServicePlanner, BindingPlanner and ImplementationPlanner. This generic planner ignores QoS specifications.!!BasicServicePlanner methodsFor: 'implementation planning' stamp: 'ras 6/3/2005 23:39'!plan: aServiceMirror in: context	| plans |	plans _ context implementationBroker 		plansFor: aServiceMirror.		"return already running service if one exists"	plans do: [ :plan | 		(plan state = ServiceRunning state) ifTrue: [			^aServiceMirror copyFrom: plan.		].	].		^aServiceMirror copyFrom: plans anyOne.! !BasicServicePlanner subclass: #QoSServicePlanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!QoSServicePlanner methodsFor: 'as yet unclassified' stamp: 'ras 5/16/2005 13:45'!allConfigurationsOf: aPlan in: context	| dependencies possibleDependencyResolutions simplePlans |	aPlan isProvisioned ifTrue: [ ^{aPlan.}. ].		"find all configurations for each dependency, then return all permutations"	dependencies _ aPlan unresolvedDependencies.	possibleDependencyResolutions _ Dictionary new. "store all configs for each dependency type"	dependencies keysAndValuesDo: [ :name :svcMirror | 		simplePlans _ context implementationBroker plansFor: svcMirror.		simplePlans isEmpty ifTrue: [ ^{}. ]. "no way to configure aPlan"		simplePlans do: [ :each |			possibleDependencyResolutions 				at: name 				put: (self allConfigurationsOf: each in: context).		].	].	^self allPermutationsFor: aPlan with: dependencies and: possibleDependencyResolutions.			! !!QoSServicePlanner methodsFor: 'as yet unclassified' stamp: 'ras 5/14/2005 12:16'!allPermutationsFor: aSvcMirror with: restOfDependencies and: resolutions	| allForRest firstDependency plansForFirst all anotherConfig |	restOfDependencies isEmpty 		ifTrue: [^ { aSvcMirror . } ].	firstDependency _ restOfDependencies associations first key.	plansForFirst _ resolutions at: firstDependency.	allForRest _ self 		allPermutationsFor: aSvcMirror 		with: (restOfDependencies copy removeKey: firstDependency; yourself)		and: resolutions.	all _ OrderedCollection new.	plansForFirst do: [ :eachPlan |		allForRest do: [ :eachPartialConfig |			anotherConfig _ eachPartialConfig copy.			firstDependency = 'platform'				ifTrue: [ anotherConfig architecture platform: eachPlan. ]				ifFalse: [ anotherConfig architecture componentServices 					at: firstDependency put: eachPlan.				].			all add: anotherConfig.			].		].	^all.! !!QoSServicePlanner methodsFor: 'as yet unclassified' stamp: 'ras 5/16/2005 14:32'!plan: aServiceMirror in: context	| simplePlans configuredPlans utility errorModel best |	simplePlans _ context implementationBroker plansFor: aServiceMirror.	configuredPlans _ OrderedCollection new.	simplePlans do: [ :each | 		configuredPlans addAll: (self allConfigurationsOf: each in: context). 	].	utility _ aServiceMirror behavior quality utilityFunction.	errorModel _ aServiceMirror behavior quality errorModel.	best _ (configuredPlans asSortedCollection: [ :planA :planB | 		(utility forError: (planA errorFor: errorModel)) 		>= (utility forError: (planB errorFor: errorModel)). 	]) first.	^aServiceMirror copyFrom: best.! !Magnitude subclass: #ServiceState	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!ServiceState commentStamp: 'ras 5/6/2005 13:01' prior: 0!Application of the "State" design pattern to QuA service planning.  Subclasses represent the following life-cycle states: Specified -> Architected -> Provisioned -> Assembled -> Running.  Each subclass is responsible only for the logic of transitioning to the immediately adjacent states.  Other transitions should be delegated to the appropriate state.  For example, to get from Specified to running, the method should send #plan, #provision, #assemble, and #run in that order to the ServiceMirror.  The Specified state handles the #plan transition, the Architected state handles the #provision transition, and so forth.!!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 19:44'!< aServiceState	^self orderNumber < aServiceState orderNumber! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 19:44'!= aServiceState	^self orderNumber = aServiceState orderNumber! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:53'!assemble: aServiceMirror	"already assembled"	^aServiceMirror.! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:53'!destroy: aServiceMirror	^aServiceMirror doDestroy.! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 19:18'!equivalent: aServiceMirror with: myServiceMirror	(aServiceMirror state = self) ifFalse: [^false].	^aServiceMirror interfaces = myServiceMirror interfaces! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 19:45'!hash	^self orderNumber hash! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 5/23/2005 16:56'!objectForDataStream: refStrm	| dp |	"Since instances of my subclasses are singletons, write a proxy that will hook up with the same resource in the destination system."	dp _ DiskProxy 			global: self class name selector: #state args: #().	refStrm replace: self with: dp.	^dp.! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 19:46'!orderNumber	^self subclassResponsibility! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:54'!plan: aServiceMirror	"already planned"	^aServiceMirror.! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 5/6/2005 11:33'!printString	^self class name! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:54'!provision: aServiceMirror	"already provisioned"	^aServiceMirror.! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:54'!run: aServiceMirror	"already running"	^aServiceMirror.! !!ServiceState methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:54'!suspend: aServiceMirror	"already assembled"	^aServiceMirror.! !ServiceState subclass: #ServiceArchitected	instanceVariableNames: ''	classVariableNames: 'Singleton'	poolDictionaries: ''	category: 'QuA'!!ServiceArchitected methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 23:12'!assemble: aServiceMirror	^aServiceMirror doProvision assemble.! !!ServiceArchitected methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 23:29'!equivalent: aServiceMirror with: myServiceMirror	^(super equivalent: aServiceMirror with: myServiceMirror)		and: [aServiceMirror architecture = myServiceMirror architecture.].! !!ServiceArchitected methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 19:47'!orderNumber	^1! !!ServiceArchitected methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:57'!provision: aServiceMirror	^aServiceMirror doProvision.! !!ServiceArchitected methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 23:13'!run: aServiceMirror	^aServiceMirror doProvision run.! !!ServiceArchitected methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:58'!suspend: aServiceMirror	^aServiceMirror doAssemble.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServiceArchitected class	instanceVariableNames: ''!!ServiceArchitected class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 13:00'!initialize	Singleton _ nil.! !!ServiceArchitected class methodsFor: 'as yet unclassified' stamp: 'ras 5/6/2005 11:30'!state	Singleton ifNil: [ Singleton _ self new. ].	^Singleton! !ServiceState subclass: #ServiceAssembled	instanceVariableNames: ''	classVariableNames: 'Singleton'	poolDictionaries: ''	category: 'QuA'!!ServiceAssembled methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 19:47'!orderNumber	^3! !!ServiceAssembled methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:57'!run: aServiceMirror	^aServiceMirror doRun.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServiceAssembled class	instanceVariableNames: ''!!ServiceAssembled class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 13:01'!initialize	Singleton _ nil.! !!ServiceAssembled class methodsFor: 'as yet unclassified' stamp: 'ras 5/6/2005 11:36'!state	Singleton ifNil: [ Singleton _ self new. ].	^Singleton! !ServiceState subclass: #ServiceProvisioned	instanceVariableNames: ''	classVariableNames: 'Singleton'	poolDictionaries: ''	category: 'QuA'!!ServiceProvisioned methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:55'!assemble: aServiceMirror	^aServiceMirror doAssemble.! !!ServiceProvisioned methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 19:15'!equivalent: aServiceMirror with: myServiceMirror	(aServiceMirror state = self) ifFalse: [^false].	(aServiceMirror architecture = myServiceMirror architecture) ifFalse: [^false].	self error: 'deep structural equivalence for architecture not yet supported'.! !!ServiceProvisioned methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 19:47'!orderNumber	^2! !!ServiceProvisioned methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 23:14'!run: aServiceMirror	^aServiceMirror doAssemble run.! !!ServiceProvisioned methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:55'!suspend: aServiceMirror	^aServiceMirror doAssemble! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServiceProvisioned class	instanceVariableNames: ''!!ServiceProvisioned class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 13:01'!initialize	Singleton _ nil.! !!ServiceProvisioned class methodsFor: 'as yet unclassified' stamp: 'ras 5/6/2005 11:35'!state	Singleton ifNil: [ Singleton _ self new. ].	^Singleton! !ServiceState subclass: #ServiceRunning	instanceVariableNames: ''	classVariableNames: 'Singleton'	poolDictionaries: ''	category: 'QuA'!!ServiceRunning methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 19:47'!orderNumber	^4! !!ServiceRunning methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:55'!suspend: aServiceMirror	^aServiceMirror doSuspend! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServiceRunning class	instanceVariableNames: ''!!ServiceRunning class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 13:01'!initialize	Singleton _ nil.! !!ServiceRunning class methodsFor: 'as yet unclassified' stamp: 'ras 5/6/2005 11:36'!state	Singleton ifNil: [ Singleton _ self new. ].	^Singleton! !ServiceState subclass: #ServiceSpecified	instanceVariableNames: ''	classVariableNames: 'Singleton'	poolDictionaries: ''	category: 'QuA'!!ServiceSpecified methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 23:15'!assemble: aServiceMirror	^aServiceMirror doPlan assemble.! !!ServiceSpecified methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:54'!destroy: aServiceMirror	"has no instantiation to destroy"	^aServiceMirror! !!ServiceSpecified methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 23:30'!equivalent: aServiceMirror with: myServiceMirror	^(super equivalent: aServiceMirror with: myServiceMirror)		and: [ aServiceMirror behavior = myServiceMirror behavior. ].! !!ServiceSpecified methodsFor: 'as yet unclassified' stamp: 'ras 5/12/2005 19:46'!orderNumber	^0! !!ServiceSpecified methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 22:55'!plan: aServiceMirror	^aServiceMirror doPlan.! !!ServiceSpecified methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 23:12'!provision: aServiceMirror	^aServiceMirror doPlan provision.! !!ServiceSpecified methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 23:15'!run: aServiceMirror	^aServiceMirror doPlan run.! !!ServiceSpecified methodsFor: 'as yet unclassified' stamp: 'ras 6/3/2005 23:15'!suspend: aServiceMirror	^aServiceMirror doPlan assemble.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServiceSpecified class	instanceVariableNames: ''!!ServiceSpecified class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 13:01'!initialize	Singleton _ nil.! !!ServiceSpecified class methodsFor: 'as yet unclassified' stamp: 'ras 5/6/2005 11:35'!state	Singleton ifNil: [ Singleton _ self new. ].	^Singleton! !Object subclass: #SqueakCapsule	instanceVariableNames: 'factories locallyHostedRepositories defaultServiceContext shutdownBlocks serviceMirrorCache broker'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!SqueakCapsule methodsFor: 'configuration' stamp: 'ras 5/9/2003 15:26'!addShutdownBlock: aBlock	shutdownBlocks add: aBlock! !!SqueakCapsule methodsFor: 'configuration' stamp: 'ras 4/1/2005 12:33'!cacheStateFromFile: fileName 	| cacheState |	cacheState _ (FileStream oldFileNamed: fileName) fileInObjectAndCode.	cacheState associationsDo: [ :each |		self defaultRepository at: each key putObj: each value.	].! !!SqueakCapsule methodsFor: 'configuration' stamp: 'ras 5/29/2005 10:00'!serveRepository: aRepository	locallyHostedRepositories add: aRepository.	self defaultRepository at: aRepository quaName		putObj: aRepository.	self defaultServiceContext implementationBroker notifyAvailable: aRepository.! !!SqueakCapsule methodsFor: 'software component creation' stamp: 'ras 5/21/2005 00:30'!advertise: instanceType and: factoryType sourceCode: blueprint requires: dependencies	self advertise: instanceType and: factoryType sourceCode: blueprint requires: dependencies errorEstimator: nil.! !!SqueakCapsule methodsFor: 'software component creation' stamp: 'ras 5/21/2005 00:30'!advertise: instanceType and: factoryType sourceCode: blueprint requires: dependencies errorEstimator: anErrorPredictor	QuA advertise: (ServiceMirror		type: instanceType		architecture: (Architecture 			platform: (ServiceMirror type: factoryType)			blueprint: nil			components: dependencies			qosRelations: (QoSRelations errorPredictor: anErrorPredictor)		)	).	QuA advertise: (ServiceMirror		type: factoryType		architecture: (Architecture 			platform: (ServiceMirror type: self capsuleType)			blueprint: blueprint			components: SvcMap none			qosRelations: QoSRelations unknown		)	).! !!SqueakCapsule methodsFor: 'software component creation' stamp: 'ras 6/1/2005 16:17'!advertiseCapabilityPlan: repository factory: factoryType configuration: aMap	| dependencies factory |	dependencies _ Dictionary new.	aMap associationsDo: [ :each | dependencies at: each key put: QuA typeAny. ].	dependencies at: 'receiver' put: QuA typeAny.	factory _ self localImplementationOf: factoryType.	factory ifNil: [ self error: 'cannot find local implementation of ',factoryType printString. ].		QuA advertise: (		ServiceMirror			type: '/QuA/capability' qua			properties: (SvcMap fromValues: { 'repository'->repository. })			architecture: (				Architecture					platform: factory					blueprint: nil					components: aMap					qosRelations: (QoSRelations unknown)				)		).! !!SqueakCapsule methodsFor: 'software component creation' stamp: 'ras 5/23/2005 22:18'!copyFrom: aClass	"this code adapted from Browser"	| originalName copyName copyClass oldDefinition newDefinition |	originalName _ aClass name.	copyName _ #QuATemplate.	(Smalltalk includesKey: copyName)		ifTrue: [ (Smalltalk at: copyName) removeFromSystemUnlogged. ].	oldDefinition _ aClass definition.	newDefinition _ oldDefinition copyReplaceAll: '#' , originalName asString with: '#' , copyName asString.	copyClass _ Compiler evaluate: newDefinition logged: true.	copyClass category: 'QuATemporary'.	copyClass 			"add method signaling no logging of blueprint compilation"		compile:			'acceptsLoggingOfCompilation			^ false'		classified: ClassOrganizer default.	copyClass copyAllCategoriesFrom: (Smalltalk at: originalName).	copyClass copyAllCategoriesFrom: (Smalltalk at: originalName) class.	^copyClass! !!SqueakCapsule methodsFor: 'software component creation' stamp: 'ras 6/1/2005 16:40'!localImplementationOf: type 	"return plan for type where platform is this capsule"	| match platform |	^(QuA thisServiceContext implementationBroker plansFor: (ServiceMirror type: type))		detect: [ :plan |			platform _ plan architecture platform.			platform isAssembled ifTrue: [ 				match _ platform primaryInterface = self. 			] ifFalse: [ 				match _ platform behavior type = (QuA reflectOn: self) behavior type. 				match ifTrue: [ plan architecture platform: (QuA reflectOn: self) ].			].			match.		].! !!SqueakCapsule methodsFor: 'software component creation' stamp: 'ras 5/10/2005 10:23'!serializationFromClass: aClass	"serialize class definition"	| sourceCode copyClass |	copyClass _ self copyFrom: aClass.	" modified copy of original class"	sourceCode _ ReadWriteStream on: String new.	sourceCode header; timeStamp.	copyClass fileOutOn: sourceCode moveSource: false toFile: 0.	sourceCode trailer; reset.	^sourceCode contents.! !!SqueakCapsule methodsFor: 'private' stamp: 'ras 12/15/2004 12:25'!capsuleType	^('/QuA/capsule/', SystemVersion current version) qua! !!SqueakCapsule methodsFor: 'private' stamp: 'ras 6/1/2005 09:46'!initializeWithName: aString 	| |	shutdownBlocks _ OrderedCollection new.	factories _ Dictionary new.	"maps local factories for QuA instances to type name"	locallyHostedRepositories _ OrderedCollection new.	defaultServiceContext _ ServiceContext new		capsule: self;		planner: BasicServicePlanner new;		implementationBroker: QuABroker instance;		yourself.	self serveRepository: (VolatileRepository named: aString).	serviceMirrorCache _ Dictionary new.	"holds frequently accessed service mirrors to speed reflection"	serviceMirrorCache at: self		put: (ServiceMirror type: self capsuleType primitive: self).	serviceMirrorCache at: QuA		put: (ServiceMirror type: '/qua/QuAMOP' qua primitive: QuA).	QuA advertise: (QuA reflectOn: self).! !!SqueakCapsule methodsFor: 'private' stamp: 'ras 5/23/2005 15:18'!quaNameFor: anObject	^self defaultRepository quaNameOrNilFor: anObject.! !!SqueakCapsule methodsFor: 'private' stamp: 'ras 6/27/2004 00:01'!quaObjAt: aQuAName	| obj |	locallyHostedRepositories do: [ :rep | 		obj _ rep quaObjAt: aQuAName.		obj notNil ifTrue: [ ^obj ].	].	^nil.! !!SqueakCapsule methodsFor: 'private' stamp: 'ras 5/23/2005 16:54'!registerAsQuA: anObject	| name |	name _ self defaultRepository newActiveObjName.	self defaultRepository 		at: name		putObj: anObject.	^name! !!SqueakCapsule methodsFor: 'accessing' stamp: 'ras 6/26/2004 23:45'!defaultRepository	^locallyHostedRepositories first! !!SqueakCapsule methodsFor: 'accessing' stamp: 'ras 5/4/2003 12:07'!defaultServiceContext	^defaultServiceContext! !!SqueakCapsule methodsFor: 'accessing' stamp: 'ras 5/31/2005 13:30'!locallyHostedRepositories	^locallyHostedRepositories! !!SqueakCapsule methodsFor: 'service planning' stamp: 'ras 5/23/2005 15:40'!enable: aServiceMirror 	"assumes aServiceMirror implementation is a smalltalk class"	| factoryType class instanceType |	class := aServiceMirror primaryInterface.	factoryType := aServiceMirror behavior type.	instanceType := QuA thisServiceContext implementationBroker 				typeForFactory: factoryType.	instanceType notNil ifTrue: [factories at: instanceType put: class]! !!SqueakCapsule methodsFor: 'service planning' stamp: 'ras 5/23/2005 15:22'!instantiate: classSource with: componentServices	| newQuAName className class |	newQuAName := self defaultRepository newActiveObjName.	className _ newQuAName shortName asSymbol.		"check for and remove old junk"	class _ Smalltalk at: className ifAbsent: [ nil ].	class notNil ifTrue: [ class removeFromSystem. ].  	class _ Smalltalk at: #QuATemplate ifAbsent: [ nil ].	class notNil ifTrue: [ class removeFromSystem. ].	(ReadStream on: classSource) fileInAnnouncing: 'loading ',newQuAName printString.	class _ (Smalltalk at: #QuATemplate) rename: className.	self defaultRepository at: newQuAName putObj: class.  "replace temporary object with the real one"	^Array with: class! !!SqueakCapsule methodsFor: 'reflection on qua objects' stamp: 'ras 5/9/2005 14:56'!mirrorFor: anObject	"if we kept a cache of ServiceMirror meta objects for each service interface, we should be able to do a reverse lookup on anObject to return this mirror"	^serviceMirrorCache at: anObject ifAbsent: [nil].! !!SqueakCapsule methodsFor: 'reflection on qua objects' stamp: 'ras 5/9/2005 15:35'!quaTypeFor: obj	"this implementation assumes caller has already determined that obj refers to local object"	^factories keyAtValue: obj class ifAbsent: [ nil ].! !!SqueakCapsule methodsFor: 'finalization' stamp: 'ras 5/31/2005 13:28'!shutdown	shutdownBlocks do: [ :each | each value. ].	shutdownBlocks _ OrderedCollection new.	"now clean up all temporary classes dumped in QuATemporary category"	(SystemOrganization superclassOrder: #QuATemporary) 		do: [ :class | class removeFromSystem. ].! !Dictionary subclass: #SvcMap	instanceVariableNames: ''	classVariableNames: 'EmptyList'	poolDictionaries: ''	category: 'QuA'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SvcMap class	instanceVariableNames: ''!!SvcMap class methodsFor: 'convenience functions' stamp: 'ras 5/12/2005 17:17'!fromTypes: arrayOfAssociations	"This is just a convenience function to construct a SvcMap dictionary from a collection of associations like { key->quaType. }."	| p |	p _ self new.	arrayOfAssociations do: [ :e | 		p at: e key put: (ServiceMirror type: e value). 	].	^p.! !!SvcMap class methodsFor: 'convenience functions' stamp: 'ras 5/12/2005 18:45'!fromValues: arrayOfAssociations	"This is just a convenience function to construct a SvcMap dictionary from a collection of associations like { key->value. }."	| p |	p _ self new.	arrayOfAssociations do: [ :e | 		p at: e key put: (QuA reflectOn: e value). 	].	^p.! !!SvcMap class methodsFor: 'convenience functions' stamp: 'ras 5/15/2005 13:02'!initialize	EmptyList _ nil.! !!SvcMap class methodsFor: 'convenience functions' stamp: 'ras 9/29/2004 14:48'!none	EmptyList ifNil: [ EmptyList _ self new. ].	^EmptyList copy.! !Object subclass: #UtilityFunction	instanceVariableNames: 'errorModel weights'	classVariableNames: 'Singleton'	poolDictionaries: ''	category: 'QuA'!!UtilityFunction methodsFor: 'initialization' stamp: 'ras 9/17/2004 20:36'!errorModel: anErrorModel	errorModel _ anErrorModel! !!UtilityFunction methodsFor: 'initialization' stamp: 'ras 9/17/2004 20:34'!weights: weightMap	weights _ weightMap! !!UtilityFunction methodsFor: 'calculation' stamp: 'ras 5/15/2005 11:59'!forError: errorMap	| sum |	errorMap isNil ifTrue: [ ^0.1. ]. "return barely acceptable if can't predict error"	sum _ 0.	errorModel dimensions do: [ :d | 		sum _ sum + ((errorMap at: d)/(weights at: d)) squared. 	].	^sum sqrt negated exp.				! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UtilityFunction class	instanceVariableNames: ''!!UtilityFunction class methodsFor: 'as yet unclassified' stamp: 'ras 9/20/2004 19:39'!default	^(UtilityFunction new)! !!UtilityFunction class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 13:02'!initialize	Singleton _ nil.! !!UtilityFunction class methodsFor: 'as yet unclassified' stamp: 'ras 5/15/2005 12:16'!unknown	Singleton isNil ifTrue: [		Singleton _ UtilityFunction new.	].	^Singleton.! !Repository subclass: #VolatileRepository	instanceVariableNames: 'activeObjects activationOID'	classVariableNames: ''	poolDictionaries: ''	category: 'QuA'!!VolatileRepository commentStamp: 'ras 5/20/2004 11:35' prior: 0!Map QuANames to Volatile QuAObjects for all non-persistant QuA objects in the local capsule.!!VolatileRepository methodsFor: 'as yet unclassified' stamp: 'ras 4/1/2005 12:35'!at: aQuAName putObj: anObject	activeObjects at: aQuAName put: anObject.! !!VolatileRepository methodsFor: 'as yet unclassified' stamp: 'ras 7/17/2003 12:36'!cacheState	| aDictionary |	aDictionary _ Dictionary new.	activeObjects associationsDo: [ :each |		each key repositoryQuAName = self quaName			ifFalse: [ aDictionary at: each key put: each value. ].	].	^aDictionary.! !!VolatileRepository methodsFor: 'as yet unclassified' stamp: 'ras 4/25/2005 16:29'!initialize	activeObjects _ Dictionary new.	activationOID _ 0.! !!VolatileRepository methodsFor: 'as yet unclassified' stamp: 'ras 6/26/2004 23:30'!newActiveObjName	^QuAName new		 repository: self quaName;		 shortName: 'T',(self nextActiveOID asString);		 version: 0;		 fixLevel: 0;		 yourself.! !!VolatileRepository methodsFor: 'as yet unclassified' stamp: 'ras 3/17/2003 22:39'!nextActiveOID	^activationOID _ activationOID + 1! !!VolatileRepository methodsFor: 'as yet unclassified' stamp: 'ras 4/1/2005 12:34'!quaNameFor: anObject	| name |	name _ self quaNameOrNilFor: anObject.	name notNil ifTrue: [^name].	"else object has not been registered before"	name _ self newActiveObjName.	self at: name putObj: anObject.	^name.! !!VolatileRepository methodsFor: 'as yet unclassified' stamp: 'ras 6/26/2004 23:35'!quaNameOrNilFor: anObject	| |	^activeObjects keyAtIdentityValue: anObject ifAbsent: [^nil].! !!VolatileRepository methodsFor: 'as yet unclassified' stamp: 'ras 7/17/2003 12:15'!quaObjAt: aQuAName	^activeObjects at: aQuAName ifAbsent: [ ^nil ].! !Architecture initialize!ArchitecturePrimitive initialize!BehaviorSpec initialize!ErrorModel initialize!InputSpec initialize!QoSRelations initialize!QuABroker initialize!QualitySpec initialize!ServiceArchitected initialize!ServiceAssembled initialize!ServiceProvisioned initialize!ServiceRunning initialize!ServiceSpecified initialize!SvcMap initialize!UtilityFunction initialize!