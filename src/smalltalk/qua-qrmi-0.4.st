Object subclass: #QRMIProtocol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'QuAQRMI'!!QRMIProtocol methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 22:49'!marshalObj: anObject on: aStream	| noneYet index |	"The following attributes of a message argument are known to the designer of a concrete type which includes the message:		mutable: the state of the argument may change		shareWithCaller: changes to the state must be visible to both caller and receiver		readAccessLikely: the state of the argument is likely to be read (as opposed to only using its identity or ignoring it altogether)		writeAccessLikely: the state of the argument is likely to be modified (if mutable)	This next attribute of a message argument is known to the designer of the protocol:		serializable:  the state of the object may be reliably encoded as a binary value and decoded to create a remote copy	A remote invocation prototocol should choose to copy an argument based on the following conditions:		shared, mutable, readAccessLikely:, writeAccessLikely:, serializable		S, M, R, W, L		X, X,  X, X,  F:  pass by reference		T, T,  X, T,  T:  pass by reference		T, T,  X, F,  T:  pass by replica value, maintain replica consistency ?but pass external components by reference?		-, F,  X, -,  T:  pass by value ?but pass external components by reference? 		F, X,  T, T,  T:  pass by value ?but pass external components by reference?		F, T,  T, F,  T:  pass by value ?but pass external components by reference?		F, T,  F, T,  T:  pass by value ?but pass external components by reference?		F, T,  F, F,  T:  pass by reference (why copy if not likely to access value?)passByRef _ ~L or (L and M and S and W) or (L and M and ~S and ~R and ~W).passByReplica _ ~passByRef and (M and S and ~W).	For example, audioSegment in #output: message is not shared, is mutable, is likely to be both read and written, and is serializable, so it is copied by value.	To apply this logic, the marshalling code needs to have the concrete type object, the message selector, and the argument index.  	For serializing composite objects (those that refer to other objects), we define the above attributes to refer only to the container, and not to the referenced objects.  For example, we want to handle the case where an ordered sequence of objects is immutable, but the state of an object referenced by the collection is mutable.  To be able to decide independently how to pass components of a composite object, we need to know the same set of attributes for each component.  This imposes a large burden on the concrete type designer (to declare these attributes recursively, for the entire possible tree of argument components.  Instead, we only ask the designer to specify these values for argument components as a group so that the protocol can handle just the case of sending the container by value but the objects by reference (or by caching).  So, for example, a collection argument could be not shared, thus passed by value, while the designer indicates that the components of the collection ARE shared, and thus must be passed by reference.	We must recognize here that this design is a compromise and the QuA architecture should not be tied to it.  Could the architecture define a standard serialization API that supported making the value/reference decision on a per-interface-method-argument-component basis?  Each time the function opted for value, it would have to do a type-specific recursion to decide for the components of the component.When serializing, an object should be able distinguish between encapsulated state and external references.  Part-of-state and externally visible properties?In the Whole-Part pattern, the whole encapsulates the parts.  In a group-member relation (could be a pattern?) the members are not encapsulated.  A more general name for a relation in which a component is not encapsulated is reference-holder-referenced-object.If arg references unencapsulated components, designer could specify selector that returns collection of these, to be serialized by reference not value.	"	({ Magnitude. String. QuAName. QuAObject. UndefinedObject. Boolean. } anySatisfy: [ :simpleImmutableClass | anObject isKindOf: simpleImmutableClass ])		ifTrue: [			anObject storeOn: aStream.		] ifFalse: [	(anObject isKindOf: ArrayedCollection)		ifTrue: [			aStream 				nextPutAll: '((';				nextPutAll: anObject class name;				nextPutAll: ' new: ';				nextPutAll: anObject size printString;				nextPutAll: ')'.			noneYet _ true.			index _ 1.			anObject do: [ :each |				noneYet					ifTrue: [noneYet _ false]					ifFalse: [aStream nextPut: $;].				aStream 					nextPutAll: ' at: ';					nextPutAll: index printString;					nextPutAll: ' put: '.				index _ index + 1.				self marshalObj: each on: aStream.			].			noneYet ifFalse: [aStream nextPutAll: '; yourself'].			aStream nextPut: $)		] ifFalse: [	(anObject isKindOf: Collection)		ifTrue: [			aStream 				nextPutAll: '((';				nextPutAll: anObject class name;				nextPutAll: ' new)'.			noneYet _ true.			anObject do: [ :each |				noneYet					ifTrue: [noneYet _ false]					ifFalse: [aStream nextPut: $;].				aStream nextPutAll: ' add: '.				self marshalObj: each on: aStream.			].			noneYet ifFalse: [aStream nextPutAll: '; yourself'].			aStream nextPut: $)		] ifFalse: [	"anObject cannot be copied by value so send a reference"			aStream store: (QuAObject for: anObject).		]]].! !!QRMIProtocol methodsFor: 'as yet unclassified' stamp: 'ras 5/17/2004 18:13'!readArgumentsFrom: aStream	^self unmarshalObjFrom: (aStream upToAll: String crlf).! !!QRMIProtocol methodsFor: 'as yet unclassified' stamp: 'ras 6/1/2005 22:00'!readReceiverFrom: aStream	^QuAName fromString: (String readFrom: aStream).! !!QRMIProtocol methodsFor: 'as yet unclassified' stamp: 'ras 4/20/2004 22:05'!readSelectorFrom: aStream	^(String readFrom: aStream) asSymbol.! !!QRMIProtocol methodsFor: 'as yet unclassified' stamp: 'ras 4/20/2004 16:57'!unmarshalObjFrom: aStream	^Object readFrom: aStream.! !!QRMIProtocol methodsFor: 'as yet unclassified' stamp: 'ras 6/27/2004 12:13'!write: aQuAName selector: aSymbol arguments: args to: aStream	aStream space.	self marshalObj: aQuAName printString on: aStream.	aStream space.	self marshalObj: aSymbol asString on: aStream.	aStream space.	self marshalObj: args on: aStream. 	aStream nextPutAll: String crlf; flush.! !Object subclass: #QRMIProxy	instanceVariableNames: 'receiverName receiverType port host myProtocol'	classVariableNames: ''	poolDictionaries: ''	category: 'QuAQRMI'!!QRMIProxy methodsFor: 'message handling' stamp: 'ras 7/20/2004 15:43'!doesNotUnderstand: aMessage	"must not sent unimpleemented messages to self as this causes infinite #doesNotUnderstand: recursion." 	| socket result |	socket _ SocketStream on: (Socket newTCP connectTo: (NetNameResolver addressForName: host) port: port).Transcript show: 'connected to port ',port printString; cr.	myProtocol 		write: receiverName 		selector: aMessage selector 		arguments: aMessage arguments		to: socket.Transcript show: 'invoking: ',receiverName printString,' ',aMessage selector printString; cr.	result _ myProtocol unmarshalObjFrom: socket upToEnd.Transcript show: 'result: ',result printString; cr.	socket close.	^ result! !!QRMIProxy methodsFor: 'message handling' stamp: 'ras 6/6/2005 14:27'!size	"don't let superclass handle, this message must go to my remote object."	^self doesNotUnderstand: (Message selector: #size)! !!QRMIProxy methodsFor: 'accessing' stamp: 'ras 6/6/2005 13:28'!initializeFromProperties: configuration	port _ (configuration at: 'port') primaryInterface.	host _ (configuration at: 'host') primaryInterface.	receiverName _ QuA nameFor: (configuration at: 'receiver') primaryInterface.	myProtocol _ QuA instanceOf: '/demo/QRMIProtocol' qua.! !!QRMIProxy methodsFor: 'accessing' stamp: 'ras 5/13/2005 09:57'!metaQuAName	^receiverName! !